// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Okta.App
{
    /// <summary>
    /// This resource allows you to create and configure an OIDC Application.
    /// &gt; During an apply if there is change in status the app will first be
    /// activated or deactivated in accordance with the status change. Then, all
    /// other arguments that changed will be applied.
    /// 
    /// &gt; `okta.app.OAuthRedirectUri` has been marked deprecated and will be removed
    /// in the v5 release of the provider. Operators should manage the redirect URIs for
    /// an oauth app directly on that resource.
    /// 
    /// ### Private Keys
    /// 
    /// The private key format that an Okta OAuth app expects is PKCS#8 (unencrypted).
    /// The operator either uploads their own private key or Okta can generate one in
    /// the Admin UI Panel under the apps Client Credentials. PKCS#8 format can be
    /// identified by a header that starts with `-----BEGIN PRIVATE KEY-----`. If the
    /// operator has a PKCS#1 (unencrypted) format private key (the header starts with
    /// `-----BEGIN RSA PRIVATE KEY-----`) they can generate a PKCS#8 format
    /// key with `Openssl`:
    /// 
    /// ## Import
    /// 
    /// ```sh
    /// $ pulumi import okta:app/oAuth:OAuth example &lt;app_id&gt;
    /// ```
    /// </summary>
    [OktaResourceType("okta:app/oAuth:OAuth")]
    public partial class OAuth : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Custom error page URL
        /// </summary>
        [Output("accessibilityErrorRedirectUrl")]
        public Output<string?> AccessibilityErrorRedirectUrl { get; private set; } = null!;

        /// <summary>
        /// Custom login page URL
        /// </summary>
        [Output("accessibilityLoginRedirectUrl")]
        public Output<string?> AccessibilityLoginRedirectUrl { get; private set; } = null!;

        /// <summary>
        /// Enable self service. Default is `False`
        /// </summary>
        [Output("accessibilitySelfService")]
        public Output<bool?> AccessibilitySelfService { get; private set; } = null!;

        /// <summary>
        /// Application notes for admins.
        /// </summary>
        [Output("adminNote")]
        public Output<string?> AdminNote { get; private set; } = null!;

        /// <summary>
        /// Displays specific appLinks for the app. The value for each application link should be boolean.
        /// </summary>
        [Output("appLinksJson")]
        public Output<string?> AppLinksJson { get; private set; } = null!;

        /// <summary>
        /// Application settings in JSON format
        /// </summary>
        [Output("appSettingsJson")]
        public Output<string?> AppSettingsJson { get; private set; } = null!;

        /// <summary>
        /// The ID of the associated app*signon*policy. If this property is removed from the application the default sign-on-policy will be associated with this application. From now on, there is no need to attach AuthenticationPolicy for applications of type `SERVICE` in the upcoming release.
        /// </summary>
        [Output("authenticationPolicy")]
        public Output<string> AuthenticationPolicy { get; private set; } = null!;

        /// <summary>
        /// Requested key rotation mode. If
        /// 			auto*key*rotation isn't specified, the client automatically opts in for Okta's
        /// 			key rotation. You can update this property via the API or via the administrator
        /// 			UI.
        /// 			See: https://developer.okta.com/docs/reference/api/apps/#oauth-credential-object"
        /// </summary>
        [Output("autoKeyRotation")]
        public Output<bool?> AutoKeyRotation { get; private set; } = null!;

        /// <summary>
        /// Display auto submit toolbar
        /// </summary>
        [Output("autoSubmitToolbar")]
        public Output<bool?> AutoSubmitToolbar { get; private set; } = null!;

        /// <summary>
        /// The user provided OAuth client secret key value, this can be set when token*endpoint*auth*method is client*secret*basic. This does nothing when `omit*secret is set to true.
        /// </summary>
        [Output("clientBasicSecret")]
        public Output<string?> ClientBasicSecret { get; private set; } = null!;

        /// <summary>
        /// OAuth client ID. If set during creation, app is created with this id.
        /// </summary>
        [Output("clientId")]
        public Output<string> ClientId { get; private set; } = null!;

        /// <summary>
        /// OAuth client secret value, this is output only. This will be in plain text in your statefile unless you set OmitSecret above.
        /// </summary>
        [Output("clientSecret")]
        public Output<string> ClientSecret { get; private set; } = null!;

        /// <summary>
        /// URI to a web page providing information about the client.
        /// </summary>
        [Output("clientUri")]
        public Output<string?> ClientUri { get; private set; } = null!;

        /// <summary>
        /// *Early Access Property*. Indicates whether user consent is required or implicit. Valid values: REQUIRED, TRUSTED. Default value is TRUSTED
        /// </summary>
        [Output("consentMethod")]
        public Output<string?> ConsentMethod { get; private set; } = null!;

        /// <summary>
        /// Application notes for end users.
        /// </summary>
        [Output("enduserNote")]
        public Output<string?> EnduserNote { get; private set; } = null!;

        /// <summary>
        /// *Early Access Property*. Determines whether Okta sends sid and iss in the logout request.
        /// </summary>
        [Output("frontchannelLogoutSessionRequired")]
        public Output<bool?> FrontchannelLogoutSessionRequired { get; private set; } = null!;

        /// <summary>
        /// *Early Access Property*. URL where Okta sends the logout request. Required when ParticipateSlo is true.
        /// </summary>
        [Output("frontchannelLogoutUri")]
        public Output<string?> FrontchannelLogoutUri { get; private set; } = null!;

        /// <summary>
        /// List of OAuth 2.0 grant types. Conditional validation params found here https://developer.okta.com/docs/api/resources/apps#credentials-settings-details. Defaults to minimum requirements per app type.
        /// </summary>
        [Output("grantTypes")]
        public Output<ImmutableArray<string>> GrantTypes { get; private set; } = null!;

        /// <summary>
        /// Groups claim for an OpenID Connect client application (argument is ignored when API auth is done with OAuth 2.0 credentials)
        /// </summary>
        [Output("groupsClaim")]
        public Output<Outputs.OAuthGroupsClaim?> GroupsClaim { get; private set; } = null!;

        /// <summary>
        /// Do not display application icon on mobile app
        /// </summary>
        [Output("hideIos")]
        public Output<bool?> HideIos { get; private set; } = null!;

        /// <summary>
        /// Do not display application icon to users
        /// </summary>
        [Output("hideWeb")]
        public Output<bool?> HideWeb { get; private set; } = null!;

        /// <summary>
        /// *Early Access Property*. Enable Federation Broker Mode.
        /// </summary>
        [Output("implicitAssignment")]
        public Output<bool?> ImplicitAssignment { get; private set; } = null!;

        /// <summary>
        /// *Early Access Property*. Indicates whether the Okta Authorization Server uses the original Okta org domain URL or a custom domain URL as the issuer of ID token for this client.
        /// </summary>
        [Output("issuerMode")]
        public Output<string?> IssuerMode { get; private set; } = null!;

        /// <summary>
        /// JSON Web Key Set (JWKS) for application. Note: Inline JWKS may have compatibility issues with v6 SDK. Consider using JwksUri instead.
        /// </summary>
        [Output("jwks")]
        public Output<ImmutableArray<Outputs.OAuthJwk>> Jwks { get; private set; } = null!;

        /// <summary>
        /// URL reference to JWKS
        /// </summary>
        [Output("jwksUri")]
        public Output<string?> JwksUri { get; private set; } = null!;

        /// <summary>
        /// The Application's display name.
        /// </summary>
        [Output("label")]
        public Output<string> Label { get; private set; } = null!;

        /// <summary>
        /// The type of Idp-Initiated login that the client supports, if any
        /// </summary>
        [Output("loginMode")]
        public Output<string?> LoginMode { get; private set; } = null!;

        /// <summary>
        /// List of scopes to use for the request
        /// </summary>
        [Output("loginScopes")]
        public Output<ImmutableArray<string>> LoginScopes { get; private set; } = null!;

        /// <summary>
        /// URI that initiates login.
        /// </summary>
        [Output("loginUri")]
        public Output<string?> LoginUri { get; private set; } = null!;

        /// <summary>
        /// Local file path to the logo. The file must be in PNG, JPG, or GIF format, and less than 1 MB in size.
        /// </summary>
        [Output("logo")]
        public Output<string?> Logo { get; private set; } = null!;

        /// <summary>
        /// URI that references a logo for the client.
        /// </summary>
        [Output("logoUri")]
        public Output<string?> LogoUri { get; private set; } = null!;

        /// <summary>
        /// URL of the application's logo
        /// </summary>
        [Output("logoUrl")]
        public Output<string> LogoUrl { get; private set; } = null!;

        /// <summary>
        /// Name of the app.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// This tells the provider not manage the client*secret value in state. When this is false (the default), it will cause the auto-generated client*secret to be persisted in the ClientSecret attribute in state. This also means that every time an update to this app is run, this value is also set on the API. If this changes from false =&gt; true, the `ClientSecret` is dropped from state and the secret at the time of the apply is what remains. If this is ever changes from true =&gt; false your app will be recreated, due to the need to regenerate a secret we can store in state.
        /// </summary>
        [Output("omitSecret")]
        public Output<bool?> OmitSecret { get; private set; } = null!;

        /// <summary>
        /// *Early Access Property*. Allows the app to participate in front-channel Single Logout. Note: You can only enable ParticipateSlo for web and browser application types. When set to true, FrontchannelLogoutUri must also be provided.
        /// </summary>
        [Output("participateSlo")]
        public Output<bool?> ParticipateSlo { get; private set; } = null!;

        /// <summary>
        /// Require Proof Key for Code Exchange (PKCE) for additional verification key rotation mode. See: https://developer.okta.com/docs/reference/api/apps/#oauth-credential-object
        /// </summary>
        [Output("pkceRequired")]
        public Output<bool> PkceRequired { get; private set; } = null!;

        /// <summary>
        /// URI to web page providing client policy document.
        /// </summary>
        [Output("policyUri")]
        public Output<string?> PolicyUri { get; private set; } = null!;

        /// <summary>
        /// List of URIs for redirection after logout. Note: see okta*app*oauth*post*logout*redirect*uri for appending to this list in a decentralized way.
        /// </summary>
        [Output("postLogoutRedirectUris")]
        public Output<ImmutableArray<string>> PostLogoutRedirectUris { get; private set; } = null!;

        /// <summary>
        /// Custom JSON that represents an OAuth application's profile
        /// </summary>
        [Output("profile")]
        public Output<string?> Profile { get; private set; } = null!;

        /// <summary>
        /// List of URIs for use in the redirect-based flow. This is required for all application types except service. Note: see okta*app*oauth*redirect*uri for appending to this list in a decentralized way.
        /// </summary>
        [Output("redirectUris")]
        public Output<ImmutableArray<string>> RedirectUris { get; private set; } = null!;

        /// <summary>
        /// *Early Access Property* Grace period for token rotation, required with grant types refresh_token
        /// </summary>
        [Output("refreshTokenLeeway")]
        public Output<int?> RefreshTokenLeeway { get; private set; } = null!;

        /// <summary>
        /// *Early Access Property* Refresh token rotation behavior, required with grant types refresh_token
        /// </summary>
        [Output("refreshTokenRotation")]
        public Output<string?> RefreshTokenRotation { get; private set; } = null!;

        /// <summary>
        /// List of OAuth 2.0 response type strings. Valid values are any combination of: `Code`, `Token`, and `IdToken`.
        /// </summary>
        [Output("responseTypes")]
        public Output<ImmutableArray<string>> ResponseTypes { get; private set; } = null!;

        /// <summary>
        /// Sign on mode of application.
        /// </summary>
        [Output("signOnMode")]
        public Output<string> SignOnMode { get; private set; } = null!;

        /// <summary>
        /// Status of application. By default, it is `ACTIVE`
        /// </summary>
        [Output("status")]
        public Output<string?> Status { get; private set; } = null!;

        /// <summary>
        /// Requested authentication method for the token endpoint, valid values include:  'client*secret*basic', 'client*secret*post', 'client*secret*jwt', 'private*key*jwt', 'none', etc.
        /// </summary>
        [Output("tokenEndpointAuthMethod")]
        public Output<string?> TokenEndpointAuthMethod { get; private set; } = null!;

        /// <summary>
        /// URI to web page providing client tos (terms of service).
        /// </summary>
        [Output("tosUri")]
        public Output<string?> TosUri { get; private set; } = null!;

        /// <summary>
        /// The type of client application.
        /// </summary>
        [Output("type")]
        public Output<string> Type { get; private set; } = null!;

        /// <summary>
        /// Username template. Default: `${source.login}`
        /// </summary>
        [Output("userNameTemplate")]
        public Output<string?> UserNameTemplate { get; private set; } = null!;

        /// <summary>
        /// Push username on update. Valid values: `PUSH` and `DONT_PUSH`
        /// </summary>
        [Output("userNameTemplatePushStatus")]
        public Output<string?> UserNameTemplatePushStatus { get; private set; } = null!;

        /// <summary>
        /// Username template suffix
        /// </summary>
        [Output("userNameTemplateSuffix")]
        public Output<string?> UserNameTemplateSuffix { get; private set; } = null!;

        /// <summary>
        /// Username template type. Default: `BUILT_IN`
        /// </summary>
        [Output("userNameTemplateType")]
        public Output<string?> UserNameTemplateType { get; private set; } = null!;

        /// <summary>
        /// *Early Access Property*. Indicates if the client is allowed to use wildcard matching of redirect_uris
        /// </summary>
        [Output("wildcardRedirect")]
        public Output<string?> WildcardRedirect { get; private set; } = null!;


        /// <summary>
        /// Create a OAuth resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public OAuth(string name, OAuthArgs args, CustomResourceOptions? options = null)
            : base("okta:app/oAuth:OAuth", name, args ?? new OAuthArgs(), MakeResourceOptions(options, ""))
        {
        }

        private OAuth(string name, Input<string> id, OAuthState? state = null, CustomResourceOptions? options = null)
            : base("okta:app/oAuth:OAuth", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                AdditionalSecretOutputs =
                {
                    "clientBasicSecret",
                    "clientSecret",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing OAuth resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static OAuth Get(string name, Input<string> id, OAuthState? state = null, CustomResourceOptions? options = null)
        {
            return new OAuth(name, id, state, options);
        }
    }

    public sealed class OAuthArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Custom error page URL
        /// </summary>
        [Input("accessibilityErrorRedirectUrl")]
        public Input<string>? AccessibilityErrorRedirectUrl { get; set; }

        /// <summary>
        /// Custom login page URL
        /// </summary>
        [Input("accessibilityLoginRedirectUrl")]
        public Input<string>? AccessibilityLoginRedirectUrl { get; set; }

        /// <summary>
        /// Enable self service. Default is `False`
        /// </summary>
        [Input("accessibilitySelfService")]
        public Input<bool>? AccessibilitySelfService { get; set; }

        /// <summary>
        /// Application notes for admins.
        /// </summary>
        [Input("adminNote")]
        public Input<string>? AdminNote { get; set; }

        /// <summary>
        /// Displays specific appLinks for the app. The value for each application link should be boolean.
        /// </summary>
        [Input("appLinksJson")]
        public Input<string>? AppLinksJson { get; set; }

        /// <summary>
        /// Application settings in JSON format
        /// </summary>
        [Input("appSettingsJson")]
        public Input<string>? AppSettingsJson { get; set; }

        /// <summary>
        /// The ID of the associated app*signon*policy. If this property is removed from the application the default sign-on-policy will be associated with this application. From now on, there is no need to attach AuthenticationPolicy for applications of type `SERVICE` in the upcoming release.
        /// </summary>
        [Input("authenticationPolicy")]
        public Input<string>? AuthenticationPolicy { get; set; }

        /// <summary>
        /// Requested key rotation mode. If
        /// 			auto*key*rotation isn't specified, the client automatically opts in for Okta's
        /// 			key rotation. You can update this property via the API or via the administrator
        /// 			UI.
        /// 			See: https://developer.okta.com/docs/reference/api/apps/#oauth-credential-object"
        /// </summary>
        [Input("autoKeyRotation")]
        public Input<bool>? AutoKeyRotation { get; set; }

        /// <summary>
        /// Display auto submit toolbar
        /// </summary>
        [Input("autoSubmitToolbar")]
        public Input<bool>? AutoSubmitToolbar { get; set; }

        [Input("clientBasicSecret")]
        private Input<string>? _clientBasicSecret;

        /// <summary>
        /// The user provided OAuth client secret key value, this can be set when token*endpoint*auth*method is client*secret*basic. This does nothing when `omit*secret is set to true.
        /// </summary>
        public Input<string>? ClientBasicSecret
        {
            get => _clientBasicSecret;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _clientBasicSecret = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// OAuth client ID. If set during creation, app is created with this id.
        /// </summary>
        [Input("clientId")]
        public Input<string>? ClientId { get; set; }

        /// <summary>
        /// URI to a web page providing information about the client.
        /// </summary>
        [Input("clientUri")]
        public Input<string>? ClientUri { get; set; }

        /// <summary>
        /// *Early Access Property*. Indicates whether user consent is required or implicit. Valid values: REQUIRED, TRUSTED. Default value is TRUSTED
        /// </summary>
        [Input("consentMethod")]
        public Input<string>? ConsentMethod { get; set; }

        /// <summary>
        /// Application notes for end users.
        /// </summary>
        [Input("enduserNote")]
        public Input<string>? EnduserNote { get; set; }

        /// <summary>
        /// *Early Access Property*. Determines whether Okta sends sid and iss in the logout request.
        /// </summary>
        [Input("frontchannelLogoutSessionRequired")]
        public Input<bool>? FrontchannelLogoutSessionRequired { get; set; }

        /// <summary>
        /// *Early Access Property*. URL where Okta sends the logout request. Required when ParticipateSlo is true.
        /// </summary>
        [Input("frontchannelLogoutUri")]
        public Input<string>? FrontchannelLogoutUri { get; set; }

        [Input("grantTypes")]
        private InputList<string>? _grantTypes;

        /// <summary>
        /// List of OAuth 2.0 grant types. Conditional validation params found here https://developer.okta.com/docs/api/resources/apps#credentials-settings-details. Defaults to minimum requirements per app type.
        /// </summary>
        public InputList<string> GrantTypes
        {
            get => _grantTypes ?? (_grantTypes = new InputList<string>());
            set => _grantTypes = value;
        }

        /// <summary>
        /// Groups claim for an OpenID Connect client application (argument is ignored when API auth is done with OAuth 2.0 credentials)
        /// </summary>
        [Input("groupsClaim")]
        public Input<Inputs.OAuthGroupsClaimArgs>? GroupsClaim { get; set; }

        /// <summary>
        /// Do not display application icon on mobile app
        /// </summary>
        [Input("hideIos")]
        public Input<bool>? HideIos { get; set; }

        /// <summary>
        /// Do not display application icon to users
        /// </summary>
        [Input("hideWeb")]
        public Input<bool>? HideWeb { get; set; }

        /// <summary>
        /// *Early Access Property*. Enable Federation Broker Mode.
        /// </summary>
        [Input("implicitAssignment")]
        public Input<bool>? ImplicitAssignment { get; set; }

        /// <summary>
        /// *Early Access Property*. Indicates whether the Okta Authorization Server uses the original Okta org domain URL or a custom domain URL as the issuer of ID token for this client.
        /// </summary>
        [Input("issuerMode")]
        public Input<string>? IssuerMode { get; set; }

        [Input("jwks")]
        private InputList<Inputs.OAuthJwkArgs>? _jwks;

        /// <summary>
        /// JSON Web Key Set (JWKS) for application. Note: Inline JWKS may have compatibility issues with v6 SDK. Consider using JwksUri instead.
        /// </summary>
        public InputList<Inputs.OAuthJwkArgs> Jwks
        {
            get => _jwks ?? (_jwks = new InputList<Inputs.OAuthJwkArgs>());
            set => _jwks = value;
        }

        /// <summary>
        /// URL reference to JWKS
        /// </summary>
        [Input("jwksUri")]
        public Input<string>? JwksUri { get; set; }

        /// <summary>
        /// The Application's display name.
        /// </summary>
        [Input("label", required: true)]
        public Input<string> Label { get; set; } = null!;

        /// <summary>
        /// The type of Idp-Initiated login that the client supports, if any
        /// </summary>
        [Input("loginMode")]
        public Input<string>? LoginMode { get; set; }

        [Input("loginScopes")]
        private InputList<string>? _loginScopes;

        /// <summary>
        /// List of scopes to use for the request
        /// </summary>
        public InputList<string> LoginScopes
        {
            get => _loginScopes ?? (_loginScopes = new InputList<string>());
            set => _loginScopes = value;
        }

        /// <summary>
        /// URI that initiates login.
        /// </summary>
        [Input("loginUri")]
        public Input<string>? LoginUri { get; set; }

        /// <summary>
        /// Local file path to the logo. The file must be in PNG, JPG, or GIF format, and less than 1 MB in size.
        /// </summary>
        [Input("logo")]
        public Input<string>? Logo { get; set; }

        /// <summary>
        /// URI that references a logo for the client.
        /// </summary>
        [Input("logoUri")]
        public Input<string>? LogoUri { get; set; }

        /// <summary>
        /// This tells the provider not manage the client*secret value in state. When this is false (the default), it will cause the auto-generated client*secret to be persisted in the ClientSecret attribute in state. This also means that every time an update to this app is run, this value is also set on the API. If this changes from false =&gt; true, the `ClientSecret` is dropped from state and the secret at the time of the apply is what remains. If this is ever changes from true =&gt; false your app will be recreated, due to the need to regenerate a secret we can store in state.
        /// </summary>
        [Input("omitSecret")]
        public Input<bool>? OmitSecret { get; set; }

        /// <summary>
        /// *Early Access Property*. Allows the app to participate in front-channel Single Logout. Note: You can only enable ParticipateSlo for web and browser application types. When set to true, FrontchannelLogoutUri must also be provided.
        /// </summary>
        [Input("participateSlo")]
        public Input<bool>? ParticipateSlo { get; set; }

        /// <summary>
        /// Require Proof Key for Code Exchange (PKCE) for additional verification key rotation mode. See: https://developer.okta.com/docs/reference/api/apps/#oauth-credential-object
        /// </summary>
        [Input("pkceRequired")]
        public Input<bool>? PkceRequired { get; set; }

        /// <summary>
        /// URI to web page providing client policy document.
        /// </summary>
        [Input("policyUri")]
        public Input<string>? PolicyUri { get; set; }

        [Input("postLogoutRedirectUris")]
        private InputList<string>? _postLogoutRedirectUris;

        /// <summary>
        /// List of URIs for redirection after logout. Note: see okta*app*oauth*post*logout*redirect*uri for appending to this list in a decentralized way.
        /// </summary>
        public InputList<string> PostLogoutRedirectUris
        {
            get => _postLogoutRedirectUris ?? (_postLogoutRedirectUris = new InputList<string>());
            set => _postLogoutRedirectUris = value;
        }

        /// <summary>
        /// Custom JSON that represents an OAuth application's profile
        /// </summary>
        [Input("profile")]
        public Input<string>? Profile { get; set; }

        [Input("redirectUris")]
        private InputList<string>? _redirectUris;

        /// <summary>
        /// List of URIs for use in the redirect-based flow. This is required for all application types except service. Note: see okta*app*oauth*redirect*uri for appending to this list in a decentralized way.
        /// </summary>
        public InputList<string> RedirectUris
        {
            get => _redirectUris ?? (_redirectUris = new InputList<string>());
            set => _redirectUris = value;
        }

        /// <summary>
        /// *Early Access Property* Grace period for token rotation, required with grant types refresh_token
        /// </summary>
        [Input("refreshTokenLeeway")]
        public Input<int>? RefreshTokenLeeway { get; set; }

        /// <summary>
        /// *Early Access Property* Refresh token rotation behavior, required with grant types refresh_token
        /// </summary>
        [Input("refreshTokenRotation")]
        public Input<string>? RefreshTokenRotation { get; set; }

        [Input("responseTypes")]
        private InputList<string>? _responseTypes;

        /// <summary>
        /// List of OAuth 2.0 response type strings. Valid values are any combination of: `Code`, `Token`, and `IdToken`.
        /// </summary>
        public InputList<string> ResponseTypes
        {
            get => _responseTypes ?? (_responseTypes = new InputList<string>());
            set => _responseTypes = value;
        }

        /// <summary>
        /// Status of application. By default, it is `ACTIVE`
        /// </summary>
        [Input("status")]
        public Input<string>? Status { get; set; }

        /// <summary>
        /// Requested authentication method for the token endpoint, valid values include:  'client*secret*basic', 'client*secret*post', 'client*secret*jwt', 'private*key*jwt', 'none', etc.
        /// </summary>
        [Input("tokenEndpointAuthMethod")]
        public Input<string>? TokenEndpointAuthMethod { get; set; }

        /// <summary>
        /// URI to web page providing client tos (terms of service).
        /// </summary>
        [Input("tosUri")]
        public Input<string>? TosUri { get; set; }

        /// <summary>
        /// The type of client application.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        /// <summary>
        /// Username template. Default: `${source.login}`
        /// </summary>
        [Input("userNameTemplate")]
        public Input<string>? UserNameTemplate { get; set; }

        /// <summary>
        /// Push username on update. Valid values: `PUSH` and `DONT_PUSH`
        /// </summary>
        [Input("userNameTemplatePushStatus")]
        public Input<string>? UserNameTemplatePushStatus { get; set; }

        /// <summary>
        /// Username template suffix
        /// </summary>
        [Input("userNameTemplateSuffix")]
        public Input<string>? UserNameTemplateSuffix { get; set; }

        /// <summary>
        /// Username template type. Default: `BUILT_IN`
        /// </summary>
        [Input("userNameTemplateType")]
        public Input<string>? UserNameTemplateType { get; set; }

        /// <summary>
        /// *Early Access Property*. Indicates if the client is allowed to use wildcard matching of redirect_uris
        /// </summary>
        [Input("wildcardRedirect")]
        public Input<string>? WildcardRedirect { get; set; }

        public OAuthArgs()
        {
        }
        public static new OAuthArgs Empty => new OAuthArgs();
    }

    public sealed class OAuthState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Custom error page URL
        /// </summary>
        [Input("accessibilityErrorRedirectUrl")]
        public Input<string>? AccessibilityErrorRedirectUrl { get; set; }

        /// <summary>
        /// Custom login page URL
        /// </summary>
        [Input("accessibilityLoginRedirectUrl")]
        public Input<string>? AccessibilityLoginRedirectUrl { get; set; }

        /// <summary>
        /// Enable self service. Default is `False`
        /// </summary>
        [Input("accessibilitySelfService")]
        public Input<bool>? AccessibilitySelfService { get; set; }

        /// <summary>
        /// Application notes for admins.
        /// </summary>
        [Input("adminNote")]
        public Input<string>? AdminNote { get; set; }

        /// <summary>
        /// Displays specific appLinks for the app. The value for each application link should be boolean.
        /// </summary>
        [Input("appLinksJson")]
        public Input<string>? AppLinksJson { get; set; }

        /// <summary>
        /// Application settings in JSON format
        /// </summary>
        [Input("appSettingsJson")]
        public Input<string>? AppSettingsJson { get; set; }

        /// <summary>
        /// The ID of the associated app*signon*policy. If this property is removed from the application the default sign-on-policy will be associated with this application. From now on, there is no need to attach AuthenticationPolicy for applications of type `SERVICE` in the upcoming release.
        /// </summary>
        [Input("authenticationPolicy")]
        public Input<string>? AuthenticationPolicy { get; set; }

        /// <summary>
        /// Requested key rotation mode. If
        /// 			auto*key*rotation isn't specified, the client automatically opts in for Okta's
        /// 			key rotation. You can update this property via the API or via the administrator
        /// 			UI.
        /// 			See: https://developer.okta.com/docs/reference/api/apps/#oauth-credential-object"
        /// </summary>
        [Input("autoKeyRotation")]
        public Input<bool>? AutoKeyRotation { get; set; }

        /// <summary>
        /// Display auto submit toolbar
        /// </summary>
        [Input("autoSubmitToolbar")]
        public Input<bool>? AutoSubmitToolbar { get; set; }

        [Input("clientBasicSecret")]
        private Input<string>? _clientBasicSecret;

        /// <summary>
        /// The user provided OAuth client secret key value, this can be set when token*endpoint*auth*method is client*secret*basic. This does nothing when `omit*secret is set to true.
        /// </summary>
        public Input<string>? ClientBasicSecret
        {
            get => _clientBasicSecret;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _clientBasicSecret = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// OAuth client ID. If set during creation, app is created with this id.
        /// </summary>
        [Input("clientId")]
        public Input<string>? ClientId { get; set; }

        [Input("clientSecret")]
        private Input<string>? _clientSecret;

        /// <summary>
        /// OAuth client secret value, this is output only. This will be in plain text in your statefile unless you set OmitSecret above.
        /// </summary>
        public Input<string>? ClientSecret
        {
            get => _clientSecret;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _clientSecret = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// URI to a web page providing information about the client.
        /// </summary>
        [Input("clientUri")]
        public Input<string>? ClientUri { get; set; }

        /// <summary>
        /// *Early Access Property*. Indicates whether user consent is required or implicit. Valid values: REQUIRED, TRUSTED. Default value is TRUSTED
        /// </summary>
        [Input("consentMethod")]
        public Input<string>? ConsentMethod { get; set; }

        /// <summary>
        /// Application notes for end users.
        /// </summary>
        [Input("enduserNote")]
        public Input<string>? EnduserNote { get; set; }

        /// <summary>
        /// *Early Access Property*. Determines whether Okta sends sid and iss in the logout request.
        /// </summary>
        [Input("frontchannelLogoutSessionRequired")]
        public Input<bool>? FrontchannelLogoutSessionRequired { get; set; }

        /// <summary>
        /// *Early Access Property*. URL where Okta sends the logout request. Required when ParticipateSlo is true.
        /// </summary>
        [Input("frontchannelLogoutUri")]
        public Input<string>? FrontchannelLogoutUri { get; set; }

        [Input("grantTypes")]
        private InputList<string>? _grantTypes;

        /// <summary>
        /// List of OAuth 2.0 grant types. Conditional validation params found here https://developer.okta.com/docs/api/resources/apps#credentials-settings-details. Defaults to minimum requirements per app type.
        /// </summary>
        public InputList<string> GrantTypes
        {
            get => _grantTypes ?? (_grantTypes = new InputList<string>());
            set => _grantTypes = value;
        }

        /// <summary>
        /// Groups claim for an OpenID Connect client application (argument is ignored when API auth is done with OAuth 2.0 credentials)
        /// </summary>
        [Input("groupsClaim")]
        public Input<Inputs.OAuthGroupsClaimGetArgs>? GroupsClaim { get; set; }

        /// <summary>
        /// Do not display application icon on mobile app
        /// </summary>
        [Input("hideIos")]
        public Input<bool>? HideIos { get; set; }

        /// <summary>
        /// Do not display application icon to users
        /// </summary>
        [Input("hideWeb")]
        public Input<bool>? HideWeb { get; set; }

        /// <summary>
        /// *Early Access Property*. Enable Federation Broker Mode.
        /// </summary>
        [Input("implicitAssignment")]
        public Input<bool>? ImplicitAssignment { get; set; }

        /// <summary>
        /// *Early Access Property*. Indicates whether the Okta Authorization Server uses the original Okta org domain URL or a custom domain URL as the issuer of ID token for this client.
        /// </summary>
        [Input("issuerMode")]
        public Input<string>? IssuerMode { get; set; }

        [Input("jwks")]
        private InputList<Inputs.OAuthJwkGetArgs>? _jwks;

        /// <summary>
        /// JSON Web Key Set (JWKS) for application. Note: Inline JWKS may have compatibility issues with v6 SDK. Consider using JwksUri instead.
        /// </summary>
        public InputList<Inputs.OAuthJwkGetArgs> Jwks
        {
            get => _jwks ?? (_jwks = new InputList<Inputs.OAuthJwkGetArgs>());
            set => _jwks = value;
        }

        /// <summary>
        /// URL reference to JWKS
        /// </summary>
        [Input("jwksUri")]
        public Input<string>? JwksUri { get; set; }

        /// <summary>
        /// The Application's display name.
        /// </summary>
        [Input("label")]
        public Input<string>? Label { get; set; }

        /// <summary>
        /// The type of Idp-Initiated login that the client supports, if any
        /// </summary>
        [Input("loginMode")]
        public Input<string>? LoginMode { get; set; }

        [Input("loginScopes")]
        private InputList<string>? _loginScopes;

        /// <summary>
        /// List of scopes to use for the request
        /// </summary>
        public InputList<string> LoginScopes
        {
            get => _loginScopes ?? (_loginScopes = new InputList<string>());
            set => _loginScopes = value;
        }

        /// <summary>
        /// URI that initiates login.
        /// </summary>
        [Input("loginUri")]
        public Input<string>? LoginUri { get; set; }

        /// <summary>
        /// Local file path to the logo. The file must be in PNG, JPG, or GIF format, and less than 1 MB in size.
        /// </summary>
        [Input("logo")]
        public Input<string>? Logo { get; set; }

        /// <summary>
        /// URI that references a logo for the client.
        /// </summary>
        [Input("logoUri")]
        public Input<string>? LogoUri { get; set; }

        /// <summary>
        /// URL of the application's logo
        /// </summary>
        [Input("logoUrl")]
        public Input<string>? LogoUrl { get; set; }

        /// <summary>
        /// Name of the app.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// This tells the provider not manage the client*secret value in state. When this is false (the default), it will cause the auto-generated client*secret to be persisted in the ClientSecret attribute in state. This also means that every time an update to this app is run, this value is also set on the API. If this changes from false =&gt; true, the `ClientSecret` is dropped from state and the secret at the time of the apply is what remains. If this is ever changes from true =&gt; false your app will be recreated, due to the need to regenerate a secret we can store in state.
        /// </summary>
        [Input("omitSecret")]
        public Input<bool>? OmitSecret { get; set; }

        /// <summary>
        /// *Early Access Property*. Allows the app to participate in front-channel Single Logout. Note: You can only enable ParticipateSlo for web and browser application types. When set to true, FrontchannelLogoutUri must also be provided.
        /// </summary>
        [Input("participateSlo")]
        public Input<bool>? ParticipateSlo { get; set; }

        /// <summary>
        /// Require Proof Key for Code Exchange (PKCE) for additional verification key rotation mode. See: https://developer.okta.com/docs/reference/api/apps/#oauth-credential-object
        /// </summary>
        [Input("pkceRequired")]
        public Input<bool>? PkceRequired { get; set; }

        /// <summary>
        /// URI to web page providing client policy document.
        /// </summary>
        [Input("policyUri")]
        public Input<string>? PolicyUri { get; set; }

        [Input("postLogoutRedirectUris")]
        private InputList<string>? _postLogoutRedirectUris;

        /// <summary>
        /// List of URIs for redirection after logout. Note: see okta*app*oauth*post*logout*redirect*uri for appending to this list in a decentralized way.
        /// </summary>
        public InputList<string> PostLogoutRedirectUris
        {
            get => _postLogoutRedirectUris ?? (_postLogoutRedirectUris = new InputList<string>());
            set => _postLogoutRedirectUris = value;
        }

        /// <summary>
        /// Custom JSON that represents an OAuth application's profile
        /// </summary>
        [Input("profile")]
        public Input<string>? Profile { get; set; }

        [Input("redirectUris")]
        private InputList<string>? _redirectUris;

        /// <summary>
        /// List of URIs for use in the redirect-based flow. This is required for all application types except service. Note: see okta*app*oauth*redirect*uri for appending to this list in a decentralized way.
        /// </summary>
        public InputList<string> RedirectUris
        {
            get => _redirectUris ?? (_redirectUris = new InputList<string>());
            set => _redirectUris = value;
        }

        /// <summary>
        /// *Early Access Property* Grace period for token rotation, required with grant types refresh_token
        /// </summary>
        [Input("refreshTokenLeeway")]
        public Input<int>? RefreshTokenLeeway { get; set; }

        /// <summary>
        /// *Early Access Property* Refresh token rotation behavior, required with grant types refresh_token
        /// </summary>
        [Input("refreshTokenRotation")]
        public Input<string>? RefreshTokenRotation { get; set; }

        [Input("responseTypes")]
        private InputList<string>? _responseTypes;

        /// <summary>
        /// List of OAuth 2.0 response type strings. Valid values are any combination of: `Code`, `Token`, and `IdToken`.
        /// </summary>
        public InputList<string> ResponseTypes
        {
            get => _responseTypes ?? (_responseTypes = new InputList<string>());
            set => _responseTypes = value;
        }

        /// <summary>
        /// Sign on mode of application.
        /// </summary>
        [Input("signOnMode")]
        public Input<string>? SignOnMode { get; set; }

        /// <summary>
        /// Status of application. By default, it is `ACTIVE`
        /// </summary>
        [Input("status")]
        public Input<string>? Status { get; set; }

        /// <summary>
        /// Requested authentication method for the token endpoint, valid values include:  'client*secret*basic', 'client*secret*post', 'client*secret*jwt', 'private*key*jwt', 'none', etc.
        /// </summary>
        [Input("tokenEndpointAuthMethod")]
        public Input<string>? TokenEndpointAuthMethod { get; set; }

        /// <summary>
        /// URI to web page providing client tos (terms of service).
        /// </summary>
        [Input("tosUri")]
        public Input<string>? TosUri { get; set; }

        /// <summary>
        /// The type of client application.
        /// </summary>
        [Input("type")]
        public Input<string>? Type { get; set; }

        /// <summary>
        /// Username template. Default: `${source.login}`
        /// </summary>
        [Input("userNameTemplate")]
        public Input<string>? UserNameTemplate { get; set; }

        /// <summary>
        /// Push username on update. Valid values: `PUSH` and `DONT_PUSH`
        /// </summary>
        [Input("userNameTemplatePushStatus")]
        public Input<string>? UserNameTemplatePushStatus { get; set; }

        /// <summary>
        /// Username template suffix
        /// </summary>
        [Input("userNameTemplateSuffix")]
        public Input<string>? UserNameTemplateSuffix { get; set; }

        /// <summary>
        /// Username template type. Default: `BUILT_IN`
        /// </summary>
        [Input("userNameTemplateType")]
        public Input<string>? UserNameTemplateType { get; set; }

        /// <summary>
        /// *Early Access Property*. Indicates if the client is allowed to use wildcard matching of redirect_uris
        /// </summary>
        [Input("wildcardRedirect")]
        public Input<string>? WildcardRedirect { get; set; }

        public OAuthState()
        {
        }
        public static new OAuthState Empty => new OAuthState();
    }
}
