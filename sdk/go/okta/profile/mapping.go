// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package profile

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-okta/sdk/v4/go/okta/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a profile mapping. This resource allows you to manage a profile mapping by source and target IDs. > **NOTE:** If using this resource with OAuth2 scopes, this resource requires `okta.profileMappings.manage` scope.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-okta/sdk/v4/go/okta/profile"
//	"github.com/pulumi/pulumi-okta/sdk/v4/go/okta/user"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			user, err := user.GetUserProfileMappingSource(ctx, map[string]interface{}{}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = profile.NewMapping(ctx, "example", &profile.MappingArgs{
//				SourceId:         pulumi.String("<source id>"),
//				TargetId:         pulumi.String(user.Id),
//				DeleteWhenAbsent: pulumi.Bool(true),
//				Mappings: profile.MappingMappingArray{
//					&profile.MappingMappingArgs{
//						Id:         pulumi.String("firstName"),
//						Expression: pulumi.String("appuser.firstName"),
//					},
//					&profile.MappingMappingArgs{
//						Id:         pulumi.String("lastName"),
//						Expression: pulumi.String("appuser.lastName"),
//					},
//					&profile.MappingMappingArgs{
//						Id:         pulumi.String("email"),
//						Expression: pulumi.String("appuser.email"),
//					},
//					&profile.MappingMappingArgs{
//						Id:         pulumi.String("login"),
//						Expression: pulumi.String("appuser.email"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type Mapping struct {
	pulumi.CustomResourceState

	// Whether apply the changes to all users with this profile after updating or creating the these mappings.
	// > **WARNING:**: 'always*apply' is incompatible with OAuth 2.0 authentication and will be ignored when using that type of authentication.
	// **WARNING:** 'always*apply' makes use of an internal/private Okta API endpoint that could change without notice rendering this resource inoperable.
	AlwaysApply pulumi.BoolPtrOutput `pulumi:"alwaysApply"`
	// When turned on this flag will trigger the provider to delete mapping properties that are not defined in config. By default, we do not delete missing properties.
	DeleteWhenAbsent pulumi.BoolPtrOutput      `pulumi:"deleteWhenAbsent"`
	Mappings         MappingMappingArrayOutput `pulumi:"mappings"`
	// The source id of the mapping to manage.
	SourceId pulumi.StringOutput `pulumi:"sourceId"`
	// Name of the mapping source.
	SourceName pulumi.StringOutput `pulumi:"sourceName"`
	// ID of the mapping source.
	SourceType pulumi.StringOutput `pulumi:"sourceType"`
	// The target id of the mapping to manage.
	TargetId pulumi.StringOutput `pulumi:"targetId"`
	// Name of the mapping target.
	TargetName pulumi.StringOutput `pulumi:"targetName"`
	// ID of the mapping target.
	TargetType pulumi.StringOutput `pulumi:"targetType"`
}

// NewMapping registers a new resource with the given unique name, arguments, and options.
func NewMapping(ctx *pulumi.Context,
	name string, args *MappingArgs, opts ...pulumi.ResourceOption) (*Mapping, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.SourceId == nil {
		return nil, errors.New("invalid value for required argument 'SourceId'")
	}
	if args.TargetId == nil {
		return nil, errors.New("invalid value for required argument 'TargetId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Mapping
	err := ctx.RegisterResource("okta:profile/mapping:Mapping", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMapping gets an existing Mapping resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMapping(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MappingState, opts ...pulumi.ResourceOption) (*Mapping, error) {
	var resource Mapping
	err := ctx.ReadResource("okta:profile/mapping:Mapping", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Mapping resources.
type mappingState struct {
	// Whether apply the changes to all users with this profile after updating or creating the these mappings.
	// > **WARNING:**: 'always*apply' is incompatible with OAuth 2.0 authentication and will be ignored when using that type of authentication.
	// **WARNING:** 'always*apply' makes use of an internal/private Okta API endpoint that could change without notice rendering this resource inoperable.
	AlwaysApply *bool `pulumi:"alwaysApply"`
	// When turned on this flag will trigger the provider to delete mapping properties that are not defined in config. By default, we do not delete missing properties.
	DeleteWhenAbsent *bool            `pulumi:"deleteWhenAbsent"`
	Mappings         []MappingMapping `pulumi:"mappings"`
	// The source id of the mapping to manage.
	SourceId *string `pulumi:"sourceId"`
	// Name of the mapping source.
	SourceName *string `pulumi:"sourceName"`
	// ID of the mapping source.
	SourceType *string `pulumi:"sourceType"`
	// The target id of the mapping to manage.
	TargetId *string `pulumi:"targetId"`
	// Name of the mapping target.
	TargetName *string `pulumi:"targetName"`
	// ID of the mapping target.
	TargetType *string `pulumi:"targetType"`
}

type MappingState struct {
	// Whether apply the changes to all users with this profile after updating or creating the these mappings.
	// > **WARNING:**: 'always*apply' is incompatible with OAuth 2.0 authentication and will be ignored when using that type of authentication.
	// **WARNING:** 'always*apply' makes use of an internal/private Okta API endpoint that could change without notice rendering this resource inoperable.
	AlwaysApply pulumi.BoolPtrInput
	// When turned on this flag will trigger the provider to delete mapping properties that are not defined in config. By default, we do not delete missing properties.
	DeleteWhenAbsent pulumi.BoolPtrInput
	Mappings         MappingMappingArrayInput
	// The source id of the mapping to manage.
	SourceId pulumi.StringPtrInput
	// Name of the mapping source.
	SourceName pulumi.StringPtrInput
	// ID of the mapping source.
	SourceType pulumi.StringPtrInput
	// The target id of the mapping to manage.
	TargetId pulumi.StringPtrInput
	// Name of the mapping target.
	TargetName pulumi.StringPtrInput
	// ID of the mapping target.
	TargetType pulumi.StringPtrInput
}

func (MappingState) ElementType() reflect.Type {
	return reflect.TypeOf((*mappingState)(nil)).Elem()
}

type mappingArgs struct {
	// Whether apply the changes to all users with this profile after updating or creating the these mappings.
	// > **WARNING:**: 'always*apply' is incompatible with OAuth 2.0 authentication and will be ignored when using that type of authentication.
	// **WARNING:** 'always*apply' makes use of an internal/private Okta API endpoint that could change without notice rendering this resource inoperable.
	AlwaysApply *bool `pulumi:"alwaysApply"`
	// When turned on this flag will trigger the provider to delete mapping properties that are not defined in config. By default, we do not delete missing properties.
	DeleteWhenAbsent *bool            `pulumi:"deleteWhenAbsent"`
	Mappings         []MappingMapping `pulumi:"mappings"`
	// The source id of the mapping to manage.
	SourceId string `pulumi:"sourceId"`
	// The target id of the mapping to manage.
	TargetId string `pulumi:"targetId"`
}

// The set of arguments for constructing a Mapping resource.
type MappingArgs struct {
	// Whether apply the changes to all users with this profile after updating or creating the these mappings.
	// > **WARNING:**: 'always*apply' is incompatible with OAuth 2.0 authentication and will be ignored when using that type of authentication.
	// **WARNING:** 'always*apply' makes use of an internal/private Okta API endpoint that could change without notice rendering this resource inoperable.
	AlwaysApply pulumi.BoolPtrInput
	// When turned on this flag will trigger the provider to delete mapping properties that are not defined in config. By default, we do not delete missing properties.
	DeleteWhenAbsent pulumi.BoolPtrInput
	Mappings         MappingMappingArrayInput
	// The source id of the mapping to manage.
	SourceId pulumi.StringInput
	// The target id of the mapping to manage.
	TargetId pulumi.StringInput
}

func (MappingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*mappingArgs)(nil)).Elem()
}

type MappingInput interface {
	pulumi.Input

	ToMappingOutput() MappingOutput
	ToMappingOutputWithContext(ctx context.Context) MappingOutput
}

func (*Mapping) ElementType() reflect.Type {
	return reflect.TypeOf((**Mapping)(nil)).Elem()
}

func (i *Mapping) ToMappingOutput() MappingOutput {
	return i.ToMappingOutputWithContext(context.Background())
}

func (i *Mapping) ToMappingOutputWithContext(ctx context.Context) MappingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MappingOutput)
}

// MappingArrayInput is an input type that accepts MappingArray and MappingArrayOutput values.
// You can construct a concrete instance of `MappingArrayInput` via:
//
//	MappingArray{ MappingArgs{...} }
type MappingArrayInput interface {
	pulumi.Input

	ToMappingArrayOutput() MappingArrayOutput
	ToMappingArrayOutputWithContext(context.Context) MappingArrayOutput
}

type MappingArray []MappingInput

func (MappingArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Mapping)(nil)).Elem()
}

func (i MappingArray) ToMappingArrayOutput() MappingArrayOutput {
	return i.ToMappingArrayOutputWithContext(context.Background())
}

func (i MappingArray) ToMappingArrayOutputWithContext(ctx context.Context) MappingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MappingArrayOutput)
}

// MappingMapInput is an input type that accepts MappingMap and MappingMapOutput values.
// You can construct a concrete instance of `MappingMapInput` via:
//
//	MappingMap{ "key": MappingArgs{...} }
type MappingMapInput interface {
	pulumi.Input

	ToMappingMapOutput() MappingMapOutput
	ToMappingMapOutputWithContext(context.Context) MappingMapOutput
}

type MappingMap map[string]MappingInput

func (MappingMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Mapping)(nil)).Elem()
}

func (i MappingMap) ToMappingMapOutput() MappingMapOutput {
	return i.ToMappingMapOutputWithContext(context.Background())
}

func (i MappingMap) ToMappingMapOutputWithContext(ctx context.Context) MappingMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MappingMapOutput)
}

type MappingOutput struct{ *pulumi.OutputState }

func (MappingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Mapping)(nil)).Elem()
}

func (o MappingOutput) ToMappingOutput() MappingOutput {
	return o
}

func (o MappingOutput) ToMappingOutputWithContext(ctx context.Context) MappingOutput {
	return o
}

// Whether apply the changes to all users with this profile after updating or creating the these mappings.
// > **WARNING:**: 'always*apply' is incompatible with OAuth 2.0 authentication and will be ignored when using that type of authentication.
// **WARNING:** 'always*apply' makes use of an internal/private Okta API endpoint that could change without notice rendering this resource inoperable.
func (o MappingOutput) AlwaysApply() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Mapping) pulumi.BoolPtrOutput { return v.AlwaysApply }).(pulumi.BoolPtrOutput)
}

// When turned on this flag will trigger the provider to delete mapping properties that are not defined in config. By default, we do not delete missing properties.
func (o MappingOutput) DeleteWhenAbsent() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Mapping) pulumi.BoolPtrOutput { return v.DeleteWhenAbsent }).(pulumi.BoolPtrOutput)
}

func (o MappingOutput) Mappings() MappingMappingArrayOutput {
	return o.ApplyT(func(v *Mapping) MappingMappingArrayOutput { return v.Mappings }).(MappingMappingArrayOutput)
}

// The source id of the mapping to manage.
func (o MappingOutput) SourceId() pulumi.StringOutput {
	return o.ApplyT(func(v *Mapping) pulumi.StringOutput { return v.SourceId }).(pulumi.StringOutput)
}

// Name of the mapping source.
func (o MappingOutput) SourceName() pulumi.StringOutput {
	return o.ApplyT(func(v *Mapping) pulumi.StringOutput { return v.SourceName }).(pulumi.StringOutput)
}

// ID of the mapping source.
func (o MappingOutput) SourceType() pulumi.StringOutput {
	return o.ApplyT(func(v *Mapping) pulumi.StringOutput { return v.SourceType }).(pulumi.StringOutput)
}

// The target id of the mapping to manage.
func (o MappingOutput) TargetId() pulumi.StringOutput {
	return o.ApplyT(func(v *Mapping) pulumi.StringOutput { return v.TargetId }).(pulumi.StringOutput)
}

// Name of the mapping target.
func (o MappingOutput) TargetName() pulumi.StringOutput {
	return o.ApplyT(func(v *Mapping) pulumi.StringOutput { return v.TargetName }).(pulumi.StringOutput)
}

// ID of the mapping target.
func (o MappingOutput) TargetType() pulumi.StringOutput {
	return o.ApplyT(func(v *Mapping) pulumi.StringOutput { return v.TargetType }).(pulumi.StringOutput)
}

type MappingArrayOutput struct{ *pulumi.OutputState }

func (MappingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Mapping)(nil)).Elem()
}

func (o MappingArrayOutput) ToMappingArrayOutput() MappingArrayOutput {
	return o
}

func (o MappingArrayOutput) ToMappingArrayOutputWithContext(ctx context.Context) MappingArrayOutput {
	return o
}

func (o MappingArrayOutput) Index(i pulumi.IntInput) MappingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Mapping {
		return vs[0].([]*Mapping)[vs[1].(int)]
	}).(MappingOutput)
}

type MappingMapOutput struct{ *pulumi.OutputState }

func (MappingMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Mapping)(nil)).Elem()
}

func (o MappingMapOutput) ToMappingMapOutput() MappingMapOutput {
	return o
}

func (o MappingMapOutput) ToMappingMapOutputWithContext(ctx context.Context) MappingMapOutput {
	return o
}

func (o MappingMapOutput) MapIndex(k pulumi.StringInput) MappingOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Mapping {
		return vs[0].(map[string]*Mapping)[vs[1].(string)]
	}).(MappingOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MappingInput)(nil)).Elem(), &Mapping{})
	pulumi.RegisterInputType(reflect.TypeOf((*MappingArrayInput)(nil)).Elem(), MappingArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MappingMapInput)(nil)).Elem(), MappingMap{})
	pulumi.RegisterOutputType(MappingOutput{})
	pulumi.RegisterOutputType(MappingArrayOutput{})
	pulumi.RegisterOutputType(MappingMapOutput{})
}
