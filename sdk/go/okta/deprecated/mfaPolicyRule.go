// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package deprecated

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type MfaPolicyRule struct {
	pulumi.CustomResourceState

	// Should the user be enrolled the first time they LOGIN, the next time they are CHALLENGED, or NEVER?
	Enroll pulumi.StringPtrOutput `pulumi:"enroll"`
	// Policy Rule Name
	Name pulumi.StringOutput `pulumi:"name"`
	// Network selection mode: ANYWHERE, ZONE, ON_NETWORK, or OFF_NETWORK.
	NetworkConnection pulumi.StringPtrOutput `pulumi:"networkConnection"`
	// The zones to exclude
	NetworkExcludes pulumi.StringArrayOutput `pulumi:"networkExcludes"`
	// The zones to include
	NetworkIncludes pulumi.StringArrayOutput `pulumi:"networkIncludes"`
	// Policy ID of the Rule
	PolicyId pulumi.StringPtrOutput `pulumi:"policyId"`
	// Policy ID of the Rule
	//
	// Deprecated: Because of incorrect naming, 'policyid' field will be deprecated and then removed in the next versions of the provider. Please use 'policy_id' instead
	Policyid pulumi.StringPtrOutput `pulumi:"policyid"`
	// Policy Rule Priority, this attribute can be set to a valid priority. To avoid endless diff situation we error if an
	// invalid priority is provided. API defaults it to the last (lowest) if not there.
	Priority pulumi.IntPtrOutput `pulumi:"priority"`
	// Policy Rule Status: ACTIVE or INACTIVE.
	Status pulumi.StringPtrOutput `pulumi:"status"`
	// Set of User IDs to Exclude
	UsersExcludeds pulumi.StringArrayOutput `pulumi:"usersExcludeds"`
}

// NewMfaPolicyRule registers a new resource with the given unique name, arguments, and options.
func NewMfaPolicyRule(ctx *pulumi.Context,
	name string, args *MfaPolicyRuleArgs, opts ...pulumi.ResourceOption) (*MfaPolicyRule, error) {
	if args == nil {
		args = &MfaPolicyRuleArgs{}
	}

	var resource MfaPolicyRule
	err := ctx.RegisterResource("okta:deprecated/mfaPolicyRule:MfaPolicyRule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMfaPolicyRule gets an existing MfaPolicyRule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMfaPolicyRule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MfaPolicyRuleState, opts ...pulumi.ResourceOption) (*MfaPolicyRule, error) {
	var resource MfaPolicyRule
	err := ctx.ReadResource("okta:deprecated/mfaPolicyRule:MfaPolicyRule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MfaPolicyRule resources.
type mfaPolicyRuleState struct {
	// Should the user be enrolled the first time they LOGIN, the next time they are CHALLENGED, or NEVER?
	Enroll *string `pulumi:"enroll"`
	// Policy Rule Name
	Name *string `pulumi:"name"`
	// Network selection mode: ANYWHERE, ZONE, ON_NETWORK, or OFF_NETWORK.
	NetworkConnection *string `pulumi:"networkConnection"`
	// The zones to exclude
	NetworkExcludes []string `pulumi:"networkExcludes"`
	// The zones to include
	NetworkIncludes []string `pulumi:"networkIncludes"`
	// Policy ID of the Rule
	PolicyId *string `pulumi:"policyId"`
	// Policy ID of the Rule
	//
	// Deprecated: Because of incorrect naming, 'policyid' field will be deprecated and then removed in the next versions of the provider. Please use 'policy_id' instead
	Policyid *string `pulumi:"policyid"`
	// Policy Rule Priority, this attribute can be set to a valid priority. To avoid endless diff situation we error if an
	// invalid priority is provided. API defaults it to the last (lowest) if not there.
	Priority *int `pulumi:"priority"`
	// Policy Rule Status: ACTIVE or INACTIVE.
	Status *string `pulumi:"status"`
	// Set of User IDs to Exclude
	UsersExcludeds []string `pulumi:"usersExcludeds"`
}

type MfaPolicyRuleState struct {
	// Should the user be enrolled the first time they LOGIN, the next time they are CHALLENGED, or NEVER?
	Enroll pulumi.StringPtrInput
	// Policy Rule Name
	Name pulumi.StringPtrInput
	// Network selection mode: ANYWHERE, ZONE, ON_NETWORK, or OFF_NETWORK.
	NetworkConnection pulumi.StringPtrInput
	// The zones to exclude
	NetworkExcludes pulumi.StringArrayInput
	// The zones to include
	NetworkIncludes pulumi.StringArrayInput
	// Policy ID of the Rule
	PolicyId pulumi.StringPtrInput
	// Policy ID of the Rule
	//
	// Deprecated: Because of incorrect naming, 'policyid' field will be deprecated and then removed in the next versions of the provider. Please use 'policy_id' instead
	Policyid pulumi.StringPtrInput
	// Policy Rule Priority, this attribute can be set to a valid priority. To avoid endless diff situation we error if an
	// invalid priority is provided. API defaults it to the last (lowest) if not there.
	Priority pulumi.IntPtrInput
	// Policy Rule Status: ACTIVE or INACTIVE.
	Status pulumi.StringPtrInput
	// Set of User IDs to Exclude
	UsersExcludeds pulumi.StringArrayInput
}

func (MfaPolicyRuleState) ElementType() reflect.Type {
	return reflect.TypeOf((*mfaPolicyRuleState)(nil)).Elem()
}

type mfaPolicyRuleArgs struct {
	// Should the user be enrolled the first time they LOGIN, the next time they are CHALLENGED, or NEVER?
	Enroll *string `pulumi:"enroll"`
	// Policy Rule Name
	Name *string `pulumi:"name"`
	// Network selection mode: ANYWHERE, ZONE, ON_NETWORK, or OFF_NETWORK.
	NetworkConnection *string `pulumi:"networkConnection"`
	// The zones to exclude
	NetworkExcludes []string `pulumi:"networkExcludes"`
	// The zones to include
	NetworkIncludes []string `pulumi:"networkIncludes"`
	// Policy ID of the Rule
	PolicyId *string `pulumi:"policyId"`
	// Policy ID of the Rule
	//
	// Deprecated: Because of incorrect naming, 'policyid' field will be deprecated and then removed in the next versions of the provider. Please use 'policy_id' instead
	Policyid *string `pulumi:"policyid"`
	// Policy Rule Priority, this attribute can be set to a valid priority. To avoid endless diff situation we error if an
	// invalid priority is provided. API defaults it to the last (lowest) if not there.
	Priority *int `pulumi:"priority"`
	// Policy Rule Status: ACTIVE or INACTIVE.
	Status *string `pulumi:"status"`
	// Set of User IDs to Exclude
	UsersExcludeds []string `pulumi:"usersExcludeds"`
}

// The set of arguments for constructing a MfaPolicyRule resource.
type MfaPolicyRuleArgs struct {
	// Should the user be enrolled the first time they LOGIN, the next time they are CHALLENGED, or NEVER?
	Enroll pulumi.StringPtrInput
	// Policy Rule Name
	Name pulumi.StringPtrInput
	// Network selection mode: ANYWHERE, ZONE, ON_NETWORK, or OFF_NETWORK.
	NetworkConnection pulumi.StringPtrInput
	// The zones to exclude
	NetworkExcludes pulumi.StringArrayInput
	// The zones to include
	NetworkIncludes pulumi.StringArrayInput
	// Policy ID of the Rule
	PolicyId pulumi.StringPtrInput
	// Policy ID of the Rule
	//
	// Deprecated: Because of incorrect naming, 'policyid' field will be deprecated and then removed in the next versions of the provider. Please use 'policy_id' instead
	Policyid pulumi.StringPtrInput
	// Policy Rule Priority, this attribute can be set to a valid priority. To avoid endless diff situation we error if an
	// invalid priority is provided. API defaults it to the last (lowest) if not there.
	Priority pulumi.IntPtrInput
	// Policy Rule Status: ACTIVE or INACTIVE.
	Status pulumi.StringPtrInput
	// Set of User IDs to Exclude
	UsersExcludeds pulumi.StringArrayInput
}

func (MfaPolicyRuleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*mfaPolicyRuleArgs)(nil)).Elem()
}

type MfaPolicyRuleInput interface {
	pulumi.Input

	ToMfaPolicyRuleOutput() MfaPolicyRuleOutput
	ToMfaPolicyRuleOutputWithContext(ctx context.Context) MfaPolicyRuleOutput
}

func (*MfaPolicyRule) ElementType() reflect.Type {
	return reflect.TypeOf((*MfaPolicyRule)(nil))
}

func (i *MfaPolicyRule) ToMfaPolicyRuleOutput() MfaPolicyRuleOutput {
	return i.ToMfaPolicyRuleOutputWithContext(context.Background())
}

func (i *MfaPolicyRule) ToMfaPolicyRuleOutputWithContext(ctx context.Context) MfaPolicyRuleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MfaPolicyRuleOutput)
}

func (i *MfaPolicyRule) ToMfaPolicyRulePtrOutput() MfaPolicyRulePtrOutput {
	return i.ToMfaPolicyRulePtrOutputWithContext(context.Background())
}

func (i *MfaPolicyRule) ToMfaPolicyRulePtrOutputWithContext(ctx context.Context) MfaPolicyRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MfaPolicyRulePtrOutput)
}

type MfaPolicyRulePtrInput interface {
	pulumi.Input

	ToMfaPolicyRulePtrOutput() MfaPolicyRulePtrOutput
	ToMfaPolicyRulePtrOutputWithContext(ctx context.Context) MfaPolicyRulePtrOutput
}

type mfaPolicyRulePtrType MfaPolicyRuleArgs

func (*mfaPolicyRulePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MfaPolicyRule)(nil))
}

func (i *mfaPolicyRulePtrType) ToMfaPolicyRulePtrOutput() MfaPolicyRulePtrOutput {
	return i.ToMfaPolicyRulePtrOutputWithContext(context.Background())
}

func (i *mfaPolicyRulePtrType) ToMfaPolicyRulePtrOutputWithContext(ctx context.Context) MfaPolicyRulePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MfaPolicyRulePtrOutput)
}

// MfaPolicyRuleArrayInput is an input type that accepts MfaPolicyRuleArray and MfaPolicyRuleArrayOutput values.
// You can construct a concrete instance of `MfaPolicyRuleArrayInput` via:
//
//          MfaPolicyRuleArray{ MfaPolicyRuleArgs{...} }
type MfaPolicyRuleArrayInput interface {
	pulumi.Input

	ToMfaPolicyRuleArrayOutput() MfaPolicyRuleArrayOutput
	ToMfaPolicyRuleArrayOutputWithContext(context.Context) MfaPolicyRuleArrayOutput
}

type MfaPolicyRuleArray []MfaPolicyRuleInput

func (MfaPolicyRuleArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*MfaPolicyRule)(nil))
}

func (i MfaPolicyRuleArray) ToMfaPolicyRuleArrayOutput() MfaPolicyRuleArrayOutput {
	return i.ToMfaPolicyRuleArrayOutputWithContext(context.Background())
}

func (i MfaPolicyRuleArray) ToMfaPolicyRuleArrayOutputWithContext(ctx context.Context) MfaPolicyRuleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MfaPolicyRuleArrayOutput)
}

// MfaPolicyRuleMapInput is an input type that accepts MfaPolicyRuleMap and MfaPolicyRuleMapOutput values.
// You can construct a concrete instance of `MfaPolicyRuleMapInput` via:
//
//          MfaPolicyRuleMap{ "key": MfaPolicyRuleArgs{...} }
type MfaPolicyRuleMapInput interface {
	pulumi.Input

	ToMfaPolicyRuleMapOutput() MfaPolicyRuleMapOutput
	ToMfaPolicyRuleMapOutputWithContext(context.Context) MfaPolicyRuleMapOutput
}

type MfaPolicyRuleMap map[string]MfaPolicyRuleInput

func (MfaPolicyRuleMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*MfaPolicyRule)(nil))
}

func (i MfaPolicyRuleMap) ToMfaPolicyRuleMapOutput() MfaPolicyRuleMapOutput {
	return i.ToMfaPolicyRuleMapOutputWithContext(context.Background())
}

func (i MfaPolicyRuleMap) ToMfaPolicyRuleMapOutputWithContext(ctx context.Context) MfaPolicyRuleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MfaPolicyRuleMapOutput)
}

type MfaPolicyRuleOutput struct {
	*pulumi.OutputState
}

func (MfaPolicyRuleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MfaPolicyRule)(nil))
}

func (o MfaPolicyRuleOutput) ToMfaPolicyRuleOutput() MfaPolicyRuleOutput {
	return o
}

func (o MfaPolicyRuleOutput) ToMfaPolicyRuleOutputWithContext(ctx context.Context) MfaPolicyRuleOutput {
	return o
}

func (o MfaPolicyRuleOutput) ToMfaPolicyRulePtrOutput() MfaPolicyRulePtrOutput {
	return o.ToMfaPolicyRulePtrOutputWithContext(context.Background())
}

func (o MfaPolicyRuleOutput) ToMfaPolicyRulePtrOutputWithContext(ctx context.Context) MfaPolicyRulePtrOutput {
	return o.ApplyT(func(v MfaPolicyRule) *MfaPolicyRule {
		return &v
	}).(MfaPolicyRulePtrOutput)
}

type MfaPolicyRulePtrOutput struct {
	*pulumi.OutputState
}

func (MfaPolicyRulePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MfaPolicyRule)(nil))
}

func (o MfaPolicyRulePtrOutput) ToMfaPolicyRulePtrOutput() MfaPolicyRulePtrOutput {
	return o
}

func (o MfaPolicyRulePtrOutput) ToMfaPolicyRulePtrOutputWithContext(ctx context.Context) MfaPolicyRulePtrOutput {
	return o
}

type MfaPolicyRuleArrayOutput struct{ *pulumi.OutputState }

func (MfaPolicyRuleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MfaPolicyRule)(nil))
}

func (o MfaPolicyRuleArrayOutput) ToMfaPolicyRuleArrayOutput() MfaPolicyRuleArrayOutput {
	return o
}

func (o MfaPolicyRuleArrayOutput) ToMfaPolicyRuleArrayOutputWithContext(ctx context.Context) MfaPolicyRuleArrayOutput {
	return o
}

func (o MfaPolicyRuleArrayOutput) Index(i pulumi.IntInput) MfaPolicyRuleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MfaPolicyRule {
		return vs[0].([]MfaPolicyRule)[vs[1].(int)]
	}).(MfaPolicyRuleOutput)
}

type MfaPolicyRuleMapOutput struct{ *pulumi.OutputState }

func (MfaPolicyRuleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]MfaPolicyRule)(nil))
}

func (o MfaPolicyRuleMapOutput) ToMfaPolicyRuleMapOutput() MfaPolicyRuleMapOutput {
	return o
}

func (o MfaPolicyRuleMapOutput) ToMfaPolicyRuleMapOutputWithContext(ctx context.Context) MfaPolicyRuleMapOutput {
	return o
}

func (o MfaPolicyRuleMapOutput) MapIndex(k pulumi.StringInput) MfaPolicyRuleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) MfaPolicyRule {
		return vs[0].(map[string]MfaPolicyRule)[vs[1].(string)]
	}).(MfaPolicyRuleOutput)
}

func init() {
	pulumi.RegisterOutputType(MfaPolicyRuleOutput{})
	pulumi.RegisterOutputType(MfaPolicyRulePtrOutput{})
	pulumi.RegisterOutputType(MfaPolicyRuleArrayOutput{})
	pulumi.RegisterOutputType(MfaPolicyRuleMapOutput{})
}
