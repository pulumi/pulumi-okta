// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package app

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-okta/sdk/v6/go/okta/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Import
//
// App features can be imported using the format `{app_id}/{feature_name}`:
//
// bash
//
// ```sh
// $ pulumi import okta:app/features:Features example 0oarblaf7hWdLawNg1d7/USER_PROVISIONING
// ```
//
// bash
//
// ```sh
// $ pulumi import okta:app/features:Features inbound 0oarblaf7hWdLawNg1d7/INBOUND_PROVISIONING
// ```
type Features struct {
	pulumi.CustomResourceState

	// The ID of the application to configure features for.
	AppId pulumi.StringOutput `pulumi:"appId"`
	// Configuration block for feature capabilities. See Capabilities below.
	Capabilities FeaturesCapabilitiesPtrOutput `pulumi:"capabilities"`
	// Description of the feature.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The name of the feature to configure. Valid values:
	// * `USER_PROVISIONING` - User profiles are pushed from Okta to the third-party app.
	// * `INBOUND_PROVISIONING` - User profiles are imported from the third-party app into Okta.
	Name pulumi.StringOutput `pulumi:"name"`
	// The status of the feature. Valid values are `ENABLED` or `DISABLED`.
	Status pulumi.StringPtrOutput `pulumi:"status"`
}

// NewFeatures registers a new resource with the given unique name, arguments, and options.
func NewFeatures(ctx *pulumi.Context,
	name string, args *FeaturesArgs, opts ...pulumi.ResourceOption) (*Features, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AppId == nil {
		return nil, errors.New("invalid value for required argument 'AppId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Features
	err := ctx.RegisterResource("okta:app/features:Features", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetFeatures gets an existing Features resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetFeatures(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *FeaturesState, opts ...pulumi.ResourceOption) (*Features, error) {
	var resource Features
	err := ctx.ReadResource("okta:app/features:Features", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Features resources.
type featuresState struct {
	// The ID of the application to configure features for.
	AppId *string `pulumi:"appId"`
	// Configuration block for feature capabilities. See Capabilities below.
	Capabilities *FeaturesCapabilities `pulumi:"capabilities"`
	// Description of the feature.
	Description *string `pulumi:"description"`
	// The name of the feature to configure. Valid values:
	// * `USER_PROVISIONING` - User profiles are pushed from Okta to the third-party app.
	// * `INBOUND_PROVISIONING` - User profiles are imported from the third-party app into Okta.
	Name *string `pulumi:"name"`
	// The status of the feature. Valid values are `ENABLED` or `DISABLED`.
	Status *string `pulumi:"status"`
}

type FeaturesState struct {
	// The ID of the application to configure features for.
	AppId pulumi.StringPtrInput
	// Configuration block for feature capabilities. See Capabilities below.
	Capabilities FeaturesCapabilitiesPtrInput
	// Description of the feature.
	Description pulumi.StringPtrInput
	// The name of the feature to configure. Valid values:
	// * `USER_PROVISIONING` - User profiles are pushed from Okta to the third-party app.
	// * `INBOUND_PROVISIONING` - User profiles are imported from the third-party app into Okta.
	Name pulumi.StringPtrInput
	// The status of the feature. Valid values are `ENABLED` or `DISABLED`.
	Status pulumi.StringPtrInput
}

func (FeaturesState) ElementType() reflect.Type {
	return reflect.TypeOf((*featuresState)(nil)).Elem()
}

type featuresArgs struct {
	// The ID of the application to configure features for.
	AppId string `pulumi:"appId"`
	// Configuration block for feature capabilities. See Capabilities below.
	Capabilities *FeaturesCapabilities `pulumi:"capabilities"`
	// Description of the feature.
	Description *string `pulumi:"description"`
	// The name of the feature to configure. Valid values:
	// * `USER_PROVISIONING` - User profiles are pushed from Okta to the third-party app.
	// * `INBOUND_PROVISIONING` - User profiles are imported from the third-party app into Okta.
	Name *string `pulumi:"name"`
	// The status of the feature. Valid values are `ENABLED` or `DISABLED`.
	Status *string `pulumi:"status"`
}

// The set of arguments for constructing a Features resource.
type FeaturesArgs struct {
	// The ID of the application to configure features for.
	AppId pulumi.StringInput
	// Configuration block for feature capabilities. See Capabilities below.
	Capabilities FeaturesCapabilitiesPtrInput
	// Description of the feature.
	Description pulumi.StringPtrInput
	// The name of the feature to configure. Valid values:
	// * `USER_PROVISIONING` - User profiles are pushed from Okta to the third-party app.
	// * `INBOUND_PROVISIONING` - User profiles are imported from the third-party app into Okta.
	Name pulumi.StringPtrInput
	// The status of the feature. Valid values are `ENABLED` or `DISABLED`.
	Status pulumi.StringPtrInput
}

func (FeaturesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*featuresArgs)(nil)).Elem()
}

type FeaturesInput interface {
	pulumi.Input

	ToFeaturesOutput() FeaturesOutput
	ToFeaturesOutputWithContext(ctx context.Context) FeaturesOutput
}

func (*Features) ElementType() reflect.Type {
	return reflect.TypeOf((**Features)(nil)).Elem()
}

func (i *Features) ToFeaturesOutput() FeaturesOutput {
	return i.ToFeaturesOutputWithContext(context.Background())
}

func (i *Features) ToFeaturesOutputWithContext(ctx context.Context) FeaturesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeaturesOutput)
}

// FeaturesArrayInput is an input type that accepts FeaturesArray and FeaturesArrayOutput values.
// You can construct a concrete instance of `FeaturesArrayInput` via:
//
//	FeaturesArray{ FeaturesArgs{...} }
type FeaturesArrayInput interface {
	pulumi.Input

	ToFeaturesArrayOutput() FeaturesArrayOutput
	ToFeaturesArrayOutputWithContext(context.Context) FeaturesArrayOutput
}

type FeaturesArray []FeaturesInput

func (FeaturesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Features)(nil)).Elem()
}

func (i FeaturesArray) ToFeaturesArrayOutput() FeaturesArrayOutput {
	return i.ToFeaturesArrayOutputWithContext(context.Background())
}

func (i FeaturesArray) ToFeaturesArrayOutputWithContext(ctx context.Context) FeaturesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeaturesArrayOutput)
}

// FeaturesMapInput is an input type that accepts FeaturesMap and FeaturesMapOutput values.
// You can construct a concrete instance of `FeaturesMapInput` via:
//
//	FeaturesMap{ "key": FeaturesArgs{...} }
type FeaturesMapInput interface {
	pulumi.Input

	ToFeaturesMapOutput() FeaturesMapOutput
	ToFeaturesMapOutputWithContext(context.Context) FeaturesMapOutput
}

type FeaturesMap map[string]FeaturesInput

func (FeaturesMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Features)(nil)).Elem()
}

func (i FeaturesMap) ToFeaturesMapOutput() FeaturesMapOutput {
	return i.ToFeaturesMapOutputWithContext(context.Background())
}

func (i FeaturesMap) ToFeaturesMapOutputWithContext(ctx context.Context) FeaturesMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(FeaturesMapOutput)
}

type FeaturesOutput struct{ *pulumi.OutputState }

func (FeaturesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Features)(nil)).Elem()
}

func (o FeaturesOutput) ToFeaturesOutput() FeaturesOutput {
	return o
}

func (o FeaturesOutput) ToFeaturesOutputWithContext(ctx context.Context) FeaturesOutput {
	return o
}

// The ID of the application to configure features for.
func (o FeaturesOutput) AppId() pulumi.StringOutput {
	return o.ApplyT(func(v *Features) pulumi.StringOutput { return v.AppId }).(pulumi.StringOutput)
}

// Configuration block for feature capabilities. See Capabilities below.
func (o FeaturesOutput) Capabilities() FeaturesCapabilitiesPtrOutput {
	return o.ApplyT(func(v *Features) FeaturesCapabilitiesPtrOutput { return v.Capabilities }).(FeaturesCapabilitiesPtrOutput)
}

// Description of the feature.
func (o FeaturesOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Features) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The name of the feature to configure. Valid values:
// * `USER_PROVISIONING` - User profiles are pushed from Okta to the third-party app.
// * `INBOUND_PROVISIONING` - User profiles are imported from the third-party app into Okta.
func (o FeaturesOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Features) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The status of the feature. Valid values are `ENABLED` or `DISABLED`.
func (o FeaturesOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Features) pulumi.StringPtrOutput { return v.Status }).(pulumi.StringPtrOutput)
}

type FeaturesArrayOutput struct{ *pulumi.OutputState }

func (FeaturesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Features)(nil)).Elem()
}

func (o FeaturesArrayOutput) ToFeaturesArrayOutput() FeaturesArrayOutput {
	return o
}

func (o FeaturesArrayOutput) ToFeaturesArrayOutputWithContext(ctx context.Context) FeaturesArrayOutput {
	return o
}

func (o FeaturesArrayOutput) Index(i pulumi.IntInput) FeaturesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Features {
		return vs[0].([]*Features)[vs[1].(int)]
	}).(FeaturesOutput)
}

type FeaturesMapOutput struct{ *pulumi.OutputState }

func (FeaturesMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Features)(nil)).Elem()
}

func (o FeaturesMapOutput) ToFeaturesMapOutput() FeaturesMapOutput {
	return o
}

func (o FeaturesMapOutput) ToFeaturesMapOutputWithContext(ctx context.Context) FeaturesMapOutput {
	return o
}

func (o FeaturesMapOutput) MapIndex(k pulumi.StringInput) FeaturesOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Features {
		return vs[0].(map[string]*Features)[vs[1].(string)]
	}).(FeaturesOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*FeaturesInput)(nil)).Elem(), &Features{})
	pulumi.RegisterInputType(reflect.TypeOf((*FeaturesArrayInput)(nil)).Elem(), FeaturesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*FeaturesMapInput)(nil)).Elem(), FeaturesMap{})
	pulumi.RegisterOutputType(FeaturesOutput{})
	pulumi.RegisterOutputType(FeaturesArrayOutput{})
	pulumi.RegisterOutputType(FeaturesMapOutput{})
}
