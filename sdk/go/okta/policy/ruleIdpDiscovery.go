// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package policy

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Creates an IdP Discovery Policy Rule.
//
// This resource allows you to create and configure an IdP Discovery Policy Rule.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-okta/sdk/v2/go/okta/policy"
// 	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := policy.NewRuleIdpDiscovery(ctx, "example", &policy.RuleIdpDiscoveryArgs{
// 			AppExcludes: policy.RuleIdpDiscoveryAppExcludeArray{
// 				&policy.RuleIdpDiscoveryAppExcludeArgs{
// 					Id:   pulumi.String("<app id>"),
// 					Type: pulumi.String("APP"),
// 				},
// 				&policy.RuleIdpDiscoveryAppExcludeArgs{
// 					Name: pulumi.String("yahoo_mail"),
// 					Type: pulumi.String("APP_TYPE"),
// 				},
// 			},
// 			AppIncludes: policy.RuleIdpDiscoveryAppIncludeArray{
// 				&policy.RuleIdpDiscoveryAppIncludeArgs{
// 					Id:   pulumi.String("<app id>"),
// 					Type: pulumi.String("APP"),
// 				},
// 				&policy.RuleIdpDiscoveryAppIncludeArgs{
// 					Name: pulumi.String("<app type name>"),
// 					Type: pulumi.String("APP_TYPE"),
// 				},
// 			},
// 			IdpId:             pulumi.String("<idp id>"),
// 			IdpType:           pulumi.String("OIDC"),
// 			NetworkConnection: pulumi.String("ANYWHERE"),
// 			PlatformIncludes: policy.RuleIdpDiscoveryPlatformIncludeArray{
// 				&policy.RuleIdpDiscoveryPlatformIncludeArgs{
// 					OsType: pulumi.String("OSX"),
// 					Type:   pulumi.String("MOBILE"),
// 				},
// 			},
// 			Policyid:                pulumi.String("<policy id>"),
// 			Priority:                pulumi.Int(1),
// 			Status:                  pulumi.String("ACTIVE"),
// 			UserIdentifierAttribute: pulumi.String("company"),
// 			UserIdentifierPatterns: policy.RuleIdpDiscoveryUserIdentifierPatternArray{
// 				&policy.RuleIdpDiscoveryUserIdentifierPatternArgs{
// 					MatchType: pulumi.String("EQUALS"),
// 					Value:     pulumi.String("Articulate"),
// 				},
// 			},
// 			UserIdentifierType: pulumi.String("ATTRIBUTE"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// A Policy Rule can be imported via the Policy and Rule ID.
//
// ```sh
//  $ pulumi import okta:policy/ruleIdpDiscovery:RuleIdpDiscovery example <policy id>/<rule id>
// ```
type RuleIdpDiscovery struct {
	pulumi.CustomResourceState

	// Applications to exclude in discovery. See `appInclude` for details.
	AppExcludes RuleIdpDiscoveryAppExcludeArrayOutput `pulumi:"appExcludes"`
	// Applications to include in discovery rule.
	AppIncludes RuleIdpDiscoveryAppIncludeArrayOutput `pulumi:"appIncludes"`
	// The identifier for the Idp the rule should route to if all conditions are met.
	IdpId pulumi.StringPtrOutput `pulumi:"idpId"`
	// Type of Idp. One of: `"SAML2"`, `"IWA"`, `"AgentlessDSSO"`, `"X509"`, `"FACEBOOK"`, `"GOOGLE"`, `"LINKEDIN"`, `"MICROSOFT"`, `"OIDC"`
	IdpType pulumi.StringPtrOutput `pulumi:"idpType"`
	// Use if the `type` is `"APP_TYPE"` to indicate the type of application(s) to include in instances where an entire group (i.e. `yahooMail`) of applications should be included.
	Name pulumi.StringOutput `pulumi:"name"`
	// The network selection mode. One of `"ANYWEHRE"` or `"ZONE"`.
	NetworkConnection pulumi.StringPtrOutput `pulumi:"networkConnection"`
	// Required if `networkConnection` = `"ZONE"`. Indicates the network zones to exclude.
	NetworkExcludes pulumi.StringArrayOutput `pulumi:"networkExcludes"`
	// Required if `networkConnection` = `"ZONE"`. Indicates the network zones to include.
	NetworkIncludes  pulumi.StringArrayOutput                   `pulumi:"networkIncludes"`
	PlatformIncludes RuleIdpDiscoveryPlatformIncludeArrayOutput `pulumi:"platformIncludes"`
	// Policy ID.
	Policyid pulumi.StringOutput `pulumi:"policyid"`
	// Idp rule priority. This attribute can be set to a valid priority. To avoid an endless diff situation an error is thrown if an invalid property is provided. The Okta API defaults to the last (lowest) if not provided.
	Priority pulumi.IntPtrOutput `pulumi:"priority"`
	// Idp rule status: `"ACTIVE"` or `"INACTIVE"`. By default, it is `"ACTIVE"`.
	Status pulumi.StringPtrOutput `pulumi:"status"`
	// Profile attribute matching can only have a single value that describes the type indicated in `userIdentifierType`. This is the attribute or identifier that the `userIdentifierPatterns` are checked against.
	UserIdentifierAttribute pulumi.StringPtrOutput `pulumi:"userIdentifierAttribute"`
	// Specifies a User Identifier pattern condition to match against. If `matchType` of `"EXPRESSION"` is used, only a *single* element can be set, otherwise multiple elements of matching patterns may be provided.
	UserIdentifierPatterns RuleIdpDiscoveryUserIdentifierPatternArrayOutput `pulumi:"userIdentifierPatterns"`
	// One of: `"IDENTIFIER"`, `"ATTRIBUTE"`
	UserIdentifierType pulumi.StringPtrOutput `pulumi:"userIdentifierType"`
}

// NewRuleIdpDiscovery registers a new resource with the given unique name, arguments, and options.
func NewRuleIdpDiscovery(ctx *pulumi.Context,
	name string, args *RuleIdpDiscoveryArgs, opts ...pulumi.ResourceOption) (*RuleIdpDiscovery, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Policyid == nil {
		return nil, errors.New("invalid value for required argument 'Policyid'")
	}
	var resource RuleIdpDiscovery
	err := ctx.RegisterResource("okta:policy/ruleIdpDiscovery:RuleIdpDiscovery", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRuleIdpDiscovery gets an existing RuleIdpDiscovery resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRuleIdpDiscovery(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RuleIdpDiscoveryState, opts ...pulumi.ResourceOption) (*RuleIdpDiscovery, error) {
	var resource RuleIdpDiscovery
	err := ctx.ReadResource("okta:policy/ruleIdpDiscovery:RuleIdpDiscovery", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RuleIdpDiscovery resources.
type ruleIdpDiscoveryState struct {
	// Applications to exclude in discovery. See `appInclude` for details.
	AppExcludes []RuleIdpDiscoveryAppExclude `pulumi:"appExcludes"`
	// Applications to include in discovery rule.
	AppIncludes []RuleIdpDiscoveryAppInclude `pulumi:"appIncludes"`
	// The identifier for the Idp the rule should route to if all conditions are met.
	IdpId *string `pulumi:"idpId"`
	// Type of Idp. One of: `"SAML2"`, `"IWA"`, `"AgentlessDSSO"`, `"X509"`, `"FACEBOOK"`, `"GOOGLE"`, `"LINKEDIN"`, `"MICROSOFT"`, `"OIDC"`
	IdpType *string `pulumi:"idpType"`
	// Use if the `type` is `"APP_TYPE"` to indicate the type of application(s) to include in instances where an entire group (i.e. `yahooMail`) of applications should be included.
	Name *string `pulumi:"name"`
	// The network selection mode. One of `"ANYWEHRE"` or `"ZONE"`.
	NetworkConnection *string `pulumi:"networkConnection"`
	// Required if `networkConnection` = `"ZONE"`. Indicates the network zones to exclude.
	NetworkExcludes []string `pulumi:"networkExcludes"`
	// Required if `networkConnection` = `"ZONE"`. Indicates the network zones to include.
	NetworkIncludes  []string                          `pulumi:"networkIncludes"`
	PlatformIncludes []RuleIdpDiscoveryPlatformInclude `pulumi:"platformIncludes"`
	// Policy ID.
	Policyid *string `pulumi:"policyid"`
	// Idp rule priority. This attribute can be set to a valid priority. To avoid an endless diff situation an error is thrown if an invalid property is provided. The Okta API defaults to the last (lowest) if not provided.
	Priority *int `pulumi:"priority"`
	// Idp rule status: `"ACTIVE"` or `"INACTIVE"`. By default, it is `"ACTIVE"`.
	Status *string `pulumi:"status"`
	// Profile attribute matching can only have a single value that describes the type indicated in `userIdentifierType`. This is the attribute or identifier that the `userIdentifierPatterns` are checked against.
	UserIdentifierAttribute *string `pulumi:"userIdentifierAttribute"`
	// Specifies a User Identifier pattern condition to match against. If `matchType` of `"EXPRESSION"` is used, only a *single* element can be set, otherwise multiple elements of matching patterns may be provided.
	UserIdentifierPatterns []RuleIdpDiscoveryUserIdentifierPattern `pulumi:"userIdentifierPatterns"`
	// One of: `"IDENTIFIER"`, `"ATTRIBUTE"`
	UserIdentifierType *string `pulumi:"userIdentifierType"`
}

type RuleIdpDiscoveryState struct {
	// Applications to exclude in discovery. See `appInclude` for details.
	AppExcludes RuleIdpDiscoveryAppExcludeArrayInput
	// Applications to include in discovery rule.
	AppIncludes RuleIdpDiscoveryAppIncludeArrayInput
	// The identifier for the Idp the rule should route to if all conditions are met.
	IdpId pulumi.StringPtrInput
	// Type of Idp. One of: `"SAML2"`, `"IWA"`, `"AgentlessDSSO"`, `"X509"`, `"FACEBOOK"`, `"GOOGLE"`, `"LINKEDIN"`, `"MICROSOFT"`, `"OIDC"`
	IdpType pulumi.StringPtrInput
	// Use if the `type` is `"APP_TYPE"` to indicate the type of application(s) to include in instances where an entire group (i.e. `yahooMail`) of applications should be included.
	Name pulumi.StringPtrInput
	// The network selection mode. One of `"ANYWEHRE"` or `"ZONE"`.
	NetworkConnection pulumi.StringPtrInput
	// Required if `networkConnection` = `"ZONE"`. Indicates the network zones to exclude.
	NetworkExcludes pulumi.StringArrayInput
	// Required if `networkConnection` = `"ZONE"`. Indicates the network zones to include.
	NetworkIncludes  pulumi.StringArrayInput
	PlatformIncludes RuleIdpDiscoveryPlatformIncludeArrayInput
	// Policy ID.
	Policyid pulumi.StringPtrInput
	// Idp rule priority. This attribute can be set to a valid priority. To avoid an endless diff situation an error is thrown if an invalid property is provided. The Okta API defaults to the last (lowest) if not provided.
	Priority pulumi.IntPtrInput
	// Idp rule status: `"ACTIVE"` or `"INACTIVE"`. By default, it is `"ACTIVE"`.
	Status pulumi.StringPtrInput
	// Profile attribute matching can only have a single value that describes the type indicated in `userIdentifierType`. This is the attribute or identifier that the `userIdentifierPatterns` are checked against.
	UserIdentifierAttribute pulumi.StringPtrInput
	// Specifies a User Identifier pattern condition to match against. If `matchType` of `"EXPRESSION"` is used, only a *single* element can be set, otherwise multiple elements of matching patterns may be provided.
	UserIdentifierPatterns RuleIdpDiscoveryUserIdentifierPatternArrayInput
	// One of: `"IDENTIFIER"`, `"ATTRIBUTE"`
	UserIdentifierType pulumi.StringPtrInput
}

func (RuleIdpDiscoveryState) ElementType() reflect.Type {
	return reflect.TypeOf((*ruleIdpDiscoveryState)(nil)).Elem()
}

type ruleIdpDiscoveryArgs struct {
	// Applications to exclude in discovery. See `appInclude` for details.
	AppExcludes []RuleIdpDiscoveryAppExclude `pulumi:"appExcludes"`
	// Applications to include in discovery rule.
	AppIncludes []RuleIdpDiscoveryAppInclude `pulumi:"appIncludes"`
	// The identifier for the Idp the rule should route to if all conditions are met.
	IdpId *string `pulumi:"idpId"`
	// Type of Idp. One of: `"SAML2"`, `"IWA"`, `"AgentlessDSSO"`, `"X509"`, `"FACEBOOK"`, `"GOOGLE"`, `"LINKEDIN"`, `"MICROSOFT"`, `"OIDC"`
	IdpType *string `pulumi:"idpType"`
	// Use if the `type` is `"APP_TYPE"` to indicate the type of application(s) to include in instances where an entire group (i.e. `yahooMail`) of applications should be included.
	Name *string `pulumi:"name"`
	// The network selection mode. One of `"ANYWEHRE"` or `"ZONE"`.
	NetworkConnection *string `pulumi:"networkConnection"`
	// Required if `networkConnection` = `"ZONE"`. Indicates the network zones to exclude.
	NetworkExcludes []string `pulumi:"networkExcludes"`
	// Required if `networkConnection` = `"ZONE"`. Indicates the network zones to include.
	NetworkIncludes  []string                          `pulumi:"networkIncludes"`
	PlatformIncludes []RuleIdpDiscoveryPlatformInclude `pulumi:"platformIncludes"`
	// Policy ID.
	Policyid string `pulumi:"policyid"`
	// Idp rule priority. This attribute can be set to a valid priority. To avoid an endless diff situation an error is thrown if an invalid property is provided. The Okta API defaults to the last (lowest) if not provided.
	Priority *int `pulumi:"priority"`
	// Idp rule status: `"ACTIVE"` or `"INACTIVE"`. By default, it is `"ACTIVE"`.
	Status *string `pulumi:"status"`
	// Profile attribute matching can only have a single value that describes the type indicated in `userIdentifierType`. This is the attribute or identifier that the `userIdentifierPatterns` are checked against.
	UserIdentifierAttribute *string `pulumi:"userIdentifierAttribute"`
	// Specifies a User Identifier pattern condition to match against. If `matchType` of `"EXPRESSION"` is used, only a *single* element can be set, otherwise multiple elements of matching patterns may be provided.
	UserIdentifierPatterns []RuleIdpDiscoveryUserIdentifierPattern `pulumi:"userIdentifierPatterns"`
	// One of: `"IDENTIFIER"`, `"ATTRIBUTE"`
	UserIdentifierType *string `pulumi:"userIdentifierType"`
}

// The set of arguments for constructing a RuleIdpDiscovery resource.
type RuleIdpDiscoveryArgs struct {
	// Applications to exclude in discovery. See `appInclude` for details.
	AppExcludes RuleIdpDiscoveryAppExcludeArrayInput
	// Applications to include in discovery rule.
	AppIncludes RuleIdpDiscoveryAppIncludeArrayInput
	// The identifier for the Idp the rule should route to if all conditions are met.
	IdpId pulumi.StringPtrInput
	// Type of Idp. One of: `"SAML2"`, `"IWA"`, `"AgentlessDSSO"`, `"X509"`, `"FACEBOOK"`, `"GOOGLE"`, `"LINKEDIN"`, `"MICROSOFT"`, `"OIDC"`
	IdpType pulumi.StringPtrInput
	// Use if the `type` is `"APP_TYPE"` to indicate the type of application(s) to include in instances where an entire group (i.e. `yahooMail`) of applications should be included.
	Name pulumi.StringPtrInput
	// The network selection mode. One of `"ANYWEHRE"` or `"ZONE"`.
	NetworkConnection pulumi.StringPtrInput
	// Required if `networkConnection` = `"ZONE"`. Indicates the network zones to exclude.
	NetworkExcludes pulumi.StringArrayInput
	// Required if `networkConnection` = `"ZONE"`. Indicates the network zones to include.
	NetworkIncludes  pulumi.StringArrayInput
	PlatformIncludes RuleIdpDiscoveryPlatformIncludeArrayInput
	// Policy ID.
	Policyid pulumi.StringInput
	// Idp rule priority. This attribute can be set to a valid priority. To avoid an endless diff situation an error is thrown if an invalid property is provided. The Okta API defaults to the last (lowest) if not provided.
	Priority pulumi.IntPtrInput
	// Idp rule status: `"ACTIVE"` or `"INACTIVE"`. By default, it is `"ACTIVE"`.
	Status pulumi.StringPtrInput
	// Profile attribute matching can only have a single value that describes the type indicated in `userIdentifierType`. This is the attribute or identifier that the `userIdentifierPatterns` are checked against.
	UserIdentifierAttribute pulumi.StringPtrInput
	// Specifies a User Identifier pattern condition to match against. If `matchType` of `"EXPRESSION"` is used, only a *single* element can be set, otherwise multiple elements of matching patterns may be provided.
	UserIdentifierPatterns RuleIdpDiscoveryUserIdentifierPatternArrayInput
	// One of: `"IDENTIFIER"`, `"ATTRIBUTE"`
	UserIdentifierType pulumi.StringPtrInput
}

func (RuleIdpDiscoveryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ruleIdpDiscoveryArgs)(nil)).Elem()
}

type RuleIdpDiscoveryInput interface {
	pulumi.Input

	ToRuleIdpDiscoveryOutput() RuleIdpDiscoveryOutput
	ToRuleIdpDiscoveryOutputWithContext(ctx context.Context) RuleIdpDiscoveryOutput
}

func (*RuleIdpDiscovery) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleIdpDiscovery)(nil))
}

func (i *RuleIdpDiscovery) ToRuleIdpDiscoveryOutput() RuleIdpDiscoveryOutput {
	return i.ToRuleIdpDiscoveryOutputWithContext(context.Background())
}

func (i *RuleIdpDiscovery) ToRuleIdpDiscoveryOutputWithContext(ctx context.Context) RuleIdpDiscoveryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleIdpDiscoveryOutput)
}

func (i *RuleIdpDiscovery) ToRuleIdpDiscoveryPtrOutput() RuleIdpDiscoveryPtrOutput {
	return i.ToRuleIdpDiscoveryPtrOutputWithContext(context.Background())
}

func (i *RuleIdpDiscovery) ToRuleIdpDiscoveryPtrOutputWithContext(ctx context.Context) RuleIdpDiscoveryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleIdpDiscoveryPtrOutput)
}

type RuleIdpDiscoveryPtrInput interface {
	pulumi.Input

	ToRuleIdpDiscoveryPtrOutput() RuleIdpDiscoveryPtrOutput
	ToRuleIdpDiscoveryPtrOutputWithContext(ctx context.Context) RuleIdpDiscoveryPtrOutput
}

type ruleIdpDiscoveryPtrType RuleIdpDiscoveryArgs

func (*ruleIdpDiscoveryPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleIdpDiscovery)(nil))
}

func (i *ruleIdpDiscoveryPtrType) ToRuleIdpDiscoveryPtrOutput() RuleIdpDiscoveryPtrOutput {
	return i.ToRuleIdpDiscoveryPtrOutputWithContext(context.Background())
}

func (i *ruleIdpDiscoveryPtrType) ToRuleIdpDiscoveryPtrOutputWithContext(ctx context.Context) RuleIdpDiscoveryPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleIdpDiscoveryPtrOutput)
}

// RuleIdpDiscoveryArrayInput is an input type that accepts RuleIdpDiscoveryArray and RuleIdpDiscoveryArrayOutput values.
// You can construct a concrete instance of `RuleIdpDiscoveryArrayInput` via:
//
//          RuleIdpDiscoveryArray{ RuleIdpDiscoveryArgs{...} }
type RuleIdpDiscoveryArrayInput interface {
	pulumi.Input

	ToRuleIdpDiscoveryArrayOutput() RuleIdpDiscoveryArrayOutput
	ToRuleIdpDiscoveryArrayOutputWithContext(context.Context) RuleIdpDiscoveryArrayOutput
}

type RuleIdpDiscoveryArray []RuleIdpDiscoveryInput

func (RuleIdpDiscoveryArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*RuleIdpDiscovery)(nil))
}

func (i RuleIdpDiscoveryArray) ToRuleIdpDiscoveryArrayOutput() RuleIdpDiscoveryArrayOutput {
	return i.ToRuleIdpDiscoveryArrayOutputWithContext(context.Background())
}

func (i RuleIdpDiscoveryArray) ToRuleIdpDiscoveryArrayOutputWithContext(ctx context.Context) RuleIdpDiscoveryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleIdpDiscoveryArrayOutput)
}

// RuleIdpDiscoveryMapInput is an input type that accepts RuleIdpDiscoveryMap and RuleIdpDiscoveryMapOutput values.
// You can construct a concrete instance of `RuleIdpDiscoveryMapInput` via:
//
//          RuleIdpDiscoveryMap{ "key": RuleIdpDiscoveryArgs{...} }
type RuleIdpDiscoveryMapInput interface {
	pulumi.Input

	ToRuleIdpDiscoveryMapOutput() RuleIdpDiscoveryMapOutput
	ToRuleIdpDiscoveryMapOutputWithContext(context.Context) RuleIdpDiscoveryMapOutput
}

type RuleIdpDiscoveryMap map[string]RuleIdpDiscoveryInput

func (RuleIdpDiscoveryMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*RuleIdpDiscovery)(nil))
}

func (i RuleIdpDiscoveryMap) ToRuleIdpDiscoveryMapOutput() RuleIdpDiscoveryMapOutput {
	return i.ToRuleIdpDiscoveryMapOutputWithContext(context.Background())
}

func (i RuleIdpDiscoveryMap) ToRuleIdpDiscoveryMapOutputWithContext(ctx context.Context) RuleIdpDiscoveryMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleIdpDiscoveryMapOutput)
}

type RuleIdpDiscoveryOutput struct {
	*pulumi.OutputState
}

func (RuleIdpDiscoveryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*RuleIdpDiscovery)(nil))
}

func (o RuleIdpDiscoveryOutput) ToRuleIdpDiscoveryOutput() RuleIdpDiscoveryOutput {
	return o
}

func (o RuleIdpDiscoveryOutput) ToRuleIdpDiscoveryOutputWithContext(ctx context.Context) RuleIdpDiscoveryOutput {
	return o
}

func (o RuleIdpDiscoveryOutput) ToRuleIdpDiscoveryPtrOutput() RuleIdpDiscoveryPtrOutput {
	return o.ToRuleIdpDiscoveryPtrOutputWithContext(context.Background())
}

func (o RuleIdpDiscoveryOutput) ToRuleIdpDiscoveryPtrOutputWithContext(ctx context.Context) RuleIdpDiscoveryPtrOutput {
	return o.ApplyT(func(v RuleIdpDiscovery) *RuleIdpDiscovery {
		return &v
	}).(RuleIdpDiscoveryPtrOutput)
}

type RuleIdpDiscoveryPtrOutput struct {
	*pulumi.OutputState
}

func (RuleIdpDiscoveryPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleIdpDiscovery)(nil))
}

func (o RuleIdpDiscoveryPtrOutput) ToRuleIdpDiscoveryPtrOutput() RuleIdpDiscoveryPtrOutput {
	return o
}

func (o RuleIdpDiscoveryPtrOutput) ToRuleIdpDiscoveryPtrOutputWithContext(ctx context.Context) RuleIdpDiscoveryPtrOutput {
	return o
}

type RuleIdpDiscoveryArrayOutput struct{ *pulumi.OutputState }

func (RuleIdpDiscoveryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]RuleIdpDiscovery)(nil))
}

func (o RuleIdpDiscoveryArrayOutput) ToRuleIdpDiscoveryArrayOutput() RuleIdpDiscoveryArrayOutput {
	return o
}

func (o RuleIdpDiscoveryArrayOutput) ToRuleIdpDiscoveryArrayOutputWithContext(ctx context.Context) RuleIdpDiscoveryArrayOutput {
	return o
}

func (o RuleIdpDiscoveryArrayOutput) Index(i pulumi.IntInput) RuleIdpDiscoveryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) RuleIdpDiscovery {
		return vs[0].([]RuleIdpDiscovery)[vs[1].(int)]
	}).(RuleIdpDiscoveryOutput)
}

type RuleIdpDiscoveryMapOutput struct{ *pulumi.OutputState }

func (RuleIdpDiscoveryMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]RuleIdpDiscovery)(nil))
}

func (o RuleIdpDiscoveryMapOutput) ToRuleIdpDiscoveryMapOutput() RuleIdpDiscoveryMapOutput {
	return o
}

func (o RuleIdpDiscoveryMapOutput) ToRuleIdpDiscoveryMapOutputWithContext(ctx context.Context) RuleIdpDiscoveryMapOutput {
	return o
}

func (o RuleIdpDiscoveryMapOutput) MapIndex(k pulumi.StringInput) RuleIdpDiscoveryOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) RuleIdpDiscovery {
		return vs[0].(map[string]RuleIdpDiscovery)[vs[1].(string)]
	}).(RuleIdpDiscoveryOutput)
}

func init() {
	pulumi.RegisterOutputType(RuleIdpDiscoveryOutput{})
	pulumi.RegisterOutputType(RuleIdpDiscoveryPtrOutput{})
	pulumi.RegisterOutputType(RuleIdpDiscoveryArrayOutput{})
	pulumi.RegisterOutputType(RuleIdpDiscoveryMapOutput{})
}
