// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package policy

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-okta/sdk/v5/go/okta/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ## Import
//
// ```sh
// $ pulumi import okta:policy/mfa:Mfa example <policy_id>
// ```
type Mfa struct {
	pulumi.CustomResourceState

	// Policy Description
	Description pulumi.StringPtrOutput `pulumi:"description"`
	Duo         pulumi.StringMapOutput `pulumi:"duo"`
	// Deprecated: Since okta now support multiple external_idps, this will be deprecated. Please use `externalIdps` instead
	ExternalIdp  pulumi.StringMapOutput      `pulumi:"externalIdp"`
	ExternalIdps pulumi.StringMapArrayOutput `pulumi:"externalIdps"`
	FidoU2f      pulumi.StringMapOutput      `pulumi:"fidoU2f"`
	FidoWebauthn pulumi.StringMapOutput      `pulumi:"fidoWebauthn"`
	GoogleOtp    pulumi.StringMapOutput      `pulumi:"googleOtp"`
	// List of Group IDs to Include
	GroupsIncludeds pulumi.StringArrayOutput `pulumi:"groupsIncludeds"`
	Hotp            pulumi.StringMapOutput   `pulumi:"hotp"`
	// Is the policy using Okta Identity Engine (OIE) with authenticators instead of factors?
	IsOie pulumi.BoolPtrOutput `pulumi:"isOie"`
	// Policy Name
	Name         pulumi.StringOutput    `pulumi:"name"`
	OktaCall     pulumi.StringMapOutput `pulumi:"oktaCall"`
	OktaEmail    pulumi.StringMapOutput `pulumi:"oktaEmail"`
	OktaOtp      pulumi.StringMapOutput `pulumi:"oktaOtp"`
	OktaPassword pulumi.StringMapOutput `pulumi:"oktaPassword"`
	OktaPush     pulumi.StringMapOutput `pulumi:"oktaPush"`
	OktaQuestion pulumi.StringMapOutput `pulumi:"oktaQuestion"`
	OktaSms      pulumi.StringMapOutput `pulumi:"oktaSms"`
	OktaVerify   pulumi.StringMapOutput `pulumi:"oktaVerify"`
	OnpremMfa    pulumi.StringMapOutput `pulumi:"onpremMfa"`
	PhoneNumber  pulumi.StringMapOutput `pulumi:"phoneNumber"`
	// Policy Priority, this attribute can be set to a valid priority. To avoid endless diff situation we error if an invalid priority is provided. API defaults it to the last (lowest) if not there.
	Priority         pulumi.IntPtrOutput    `pulumi:"priority"`
	RsaToken         pulumi.StringMapOutput `pulumi:"rsaToken"`
	SecurityQuestion pulumi.StringMapOutput `pulumi:"securityQuestion"`
	SmartCardIdp     pulumi.StringMapOutput `pulumi:"smartCardIdp"`
	// Policy Status: `ACTIVE` or `INACTIVE`. Default: `ACTIVE`
	Status       pulumi.StringPtrOutput `pulumi:"status"`
	SymantecVip  pulumi.StringMapOutput `pulumi:"symantecVip"`
	Webauthn     pulumi.StringMapOutput `pulumi:"webauthn"`
	YubikeyToken pulumi.StringMapOutput `pulumi:"yubikeyToken"`
}

// NewMfa registers a new resource with the given unique name, arguments, and options.
func NewMfa(ctx *pulumi.Context,
	name string, args *MfaArgs, opts ...pulumi.ResourceOption) (*Mfa, error) {
	if args == nil {
		args = &MfaArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Mfa
	err := ctx.RegisterResource("okta:policy/mfa:Mfa", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMfa gets an existing Mfa resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMfa(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MfaState, opts ...pulumi.ResourceOption) (*Mfa, error) {
	var resource Mfa
	err := ctx.ReadResource("okta:policy/mfa:Mfa", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Mfa resources.
type mfaState struct {
	// Policy Description
	Description *string           `pulumi:"description"`
	Duo         map[string]string `pulumi:"duo"`
	// Deprecated: Since okta now support multiple external_idps, this will be deprecated. Please use `externalIdps` instead
	ExternalIdp  map[string]string   `pulumi:"externalIdp"`
	ExternalIdps []map[string]string `pulumi:"externalIdps"`
	FidoU2f      map[string]string   `pulumi:"fidoU2f"`
	FidoWebauthn map[string]string   `pulumi:"fidoWebauthn"`
	GoogleOtp    map[string]string   `pulumi:"googleOtp"`
	// List of Group IDs to Include
	GroupsIncludeds []string          `pulumi:"groupsIncludeds"`
	Hotp            map[string]string `pulumi:"hotp"`
	// Is the policy using Okta Identity Engine (OIE) with authenticators instead of factors?
	IsOie *bool `pulumi:"isOie"`
	// Policy Name
	Name         *string           `pulumi:"name"`
	OktaCall     map[string]string `pulumi:"oktaCall"`
	OktaEmail    map[string]string `pulumi:"oktaEmail"`
	OktaOtp      map[string]string `pulumi:"oktaOtp"`
	OktaPassword map[string]string `pulumi:"oktaPassword"`
	OktaPush     map[string]string `pulumi:"oktaPush"`
	OktaQuestion map[string]string `pulumi:"oktaQuestion"`
	OktaSms      map[string]string `pulumi:"oktaSms"`
	OktaVerify   map[string]string `pulumi:"oktaVerify"`
	OnpremMfa    map[string]string `pulumi:"onpremMfa"`
	PhoneNumber  map[string]string `pulumi:"phoneNumber"`
	// Policy Priority, this attribute can be set to a valid priority. To avoid endless diff situation we error if an invalid priority is provided. API defaults it to the last (lowest) if not there.
	Priority         *int              `pulumi:"priority"`
	RsaToken         map[string]string `pulumi:"rsaToken"`
	SecurityQuestion map[string]string `pulumi:"securityQuestion"`
	SmartCardIdp     map[string]string `pulumi:"smartCardIdp"`
	// Policy Status: `ACTIVE` or `INACTIVE`. Default: `ACTIVE`
	Status       *string           `pulumi:"status"`
	SymantecVip  map[string]string `pulumi:"symantecVip"`
	Webauthn     map[string]string `pulumi:"webauthn"`
	YubikeyToken map[string]string `pulumi:"yubikeyToken"`
}

type MfaState struct {
	// Policy Description
	Description pulumi.StringPtrInput
	Duo         pulumi.StringMapInput
	// Deprecated: Since okta now support multiple external_idps, this will be deprecated. Please use `externalIdps` instead
	ExternalIdp  pulumi.StringMapInput
	ExternalIdps pulumi.StringMapArrayInput
	FidoU2f      pulumi.StringMapInput
	FidoWebauthn pulumi.StringMapInput
	GoogleOtp    pulumi.StringMapInput
	// List of Group IDs to Include
	GroupsIncludeds pulumi.StringArrayInput
	Hotp            pulumi.StringMapInput
	// Is the policy using Okta Identity Engine (OIE) with authenticators instead of factors?
	IsOie pulumi.BoolPtrInput
	// Policy Name
	Name         pulumi.StringPtrInput
	OktaCall     pulumi.StringMapInput
	OktaEmail    pulumi.StringMapInput
	OktaOtp      pulumi.StringMapInput
	OktaPassword pulumi.StringMapInput
	OktaPush     pulumi.StringMapInput
	OktaQuestion pulumi.StringMapInput
	OktaSms      pulumi.StringMapInput
	OktaVerify   pulumi.StringMapInput
	OnpremMfa    pulumi.StringMapInput
	PhoneNumber  pulumi.StringMapInput
	// Policy Priority, this attribute can be set to a valid priority. To avoid endless diff situation we error if an invalid priority is provided. API defaults it to the last (lowest) if not there.
	Priority         pulumi.IntPtrInput
	RsaToken         pulumi.StringMapInput
	SecurityQuestion pulumi.StringMapInput
	SmartCardIdp     pulumi.StringMapInput
	// Policy Status: `ACTIVE` or `INACTIVE`. Default: `ACTIVE`
	Status       pulumi.StringPtrInput
	SymantecVip  pulumi.StringMapInput
	Webauthn     pulumi.StringMapInput
	YubikeyToken pulumi.StringMapInput
}

func (MfaState) ElementType() reflect.Type {
	return reflect.TypeOf((*mfaState)(nil)).Elem()
}

type mfaArgs struct {
	// Policy Description
	Description *string           `pulumi:"description"`
	Duo         map[string]string `pulumi:"duo"`
	// Deprecated: Since okta now support multiple external_idps, this will be deprecated. Please use `externalIdps` instead
	ExternalIdp  map[string]string   `pulumi:"externalIdp"`
	ExternalIdps []map[string]string `pulumi:"externalIdps"`
	FidoU2f      map[string]string   `pulumi:"fidoU2f"`
	FidoWebauthn map[string]string   `pulumi:"fidoWebauthn"`
	GoogleOtp    map[string]string   `pulumi:"googleOtp"`
	// List of Group IDs to Include
	GroupsIncludeds []string          `pulumi:"groupsIncludeds"`
	Hotp            map[string]string `pulumi:"hotp"`
	// Is the policy using Okta Identity Engine (OIE) with authenticators instead of factors?
	IsOie *bool `pulumi:"isOie"`
	// Policy Name
	Name         *string           `pulumi:"name"`
	OktaCall     map[string]string `pulumi:"oktaCall"`
	OktaEmail    map[string]string `pulumi:"oktaEmail"`
	OktaOtp      map[string]string `pulumi:"oktaOtp"`
	OktaPassword map[string]string `pulumi:"oktaPassword"`
	OktaPush     map[string]string `pulumi:"oktaPush"`
	OktaQuestion map[string]string `pulumi:"oktaQuestion"`
	OktaSms      map[string]string `pulumi:"oktaSms"`
	OktaVerify   map[string]string `pulumi:"oktaVerify"`
	OnpremMfa    map[string]string `pulumi:"onpremMfa"`
	PhoneNumber  map[string]string `pulumi:"phoneNumber"`
	// Policy Priority, this attribute can be set to a valid priority. To avoid endless diff situation we error if an invalid priority is provided. API defaults it to the last (lowest) if not there.
	Priority         *int              `pulumi:"priority"`
	RsaToken         map[string]string `pulumi:"rsaToken"`
	SecurityQuestion map[string]string `pulumi:"securityQuestion"`
	SmartCardIdp     map[string]string `pulumi:"smartCardIdp"`
	// Policy Status: `ACTIVE` or `INACTIVE`. Default: `ACTIVE`
	Status       *string           `pulumi:"status"`
	SymantecVip  map[string]string `pulumi:"symantecVip"`
	Webauthn     map[string]string `pulumi:"webauthn"`
	YubikeyToken map[string]string `pulumi:"yubikeyToken"`
}

// The set of arguments for constructing a Mfa resource.
type MfaArgs struct {
	// Policy Description
	Description pulumi.StringPtrInput
	Duo         pulumi.StringMapInput
	// Deprecated: Since okta now support multiple external_idps, this will be deprecated. Please use `externalIdps` instead
	ExternalIdp  pulumi.StringMapInput
	ExternalIdps pulumi.StringMapArrayInput
	FidoU2f      pulumi.StringMapInput
	FidoWebauthn pulumi.StringMapInput
	GoogleOtp    pulumi.StringMapInput
	// List of Group IDs to Include
	GroupsIncludeds pulumi.StringArrayInput
	Hotp            pulumi.StringMapInput
	// Is the policy using Okta Identity Engine (OIE) with authenticators instead of factors?
	IsOie pulumi.BoolPtrInput
	// Policy Name
	Name         pulumi.StringPtrInput
	OktaCall     pulumi.StringMapInput
	OktaEmail    pulumi.StringMapInput
	OktaOtp      pulumi.StringMapInput
	OktaPassword pulumi.StringMapInput
	OktaPush     pulumi.StringMapInput
	OktaQuestion pulumi.StringMapInput
	OktaSms      pulumi.StringMapInput
	OktaVerify   pulumi.StringMapInput
	OnpremMfa    pulumi.StringMapInput
	PhoneNumber  pulumi.StringMapInput
	// Policy Priority, this attribute can be set to a valid priority. To avoid endless diff situation we error if an invalid priority is provided. API defaults it to the last (lowest) if not there.
	Priority         pulumi.IntPtrInput
	RsaToken         pulumi.StringMapInput
	SecurityQuestion pulumi.StringMapInput
	SmartCardIdp     pulumi.StringMapInput
	// Policy Status: `ACTIVE` or `INACTIVE`. Default: `ACTIVE`
	Status       pulumi.StringPtrInput
	SymantecVip  pulumi.StringMapInput
	Webauthn     pulumi.StringMapInput
	YubikeyToken pulumi.StringMapInput
}

func (MfaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*mfaArgs)(nil)).Elem()
}

type MfaInput interface {
	pulumi.Input

	ToMfaOutput() MfaOutput
	ToMfaOutputWithContext(ctx context.Context) MfaOutput
}

func (*Mfa) ElementType() reflect.Type {
	return reflect.TypeOf((**Mfa)(nil)).Elem()
}

func (i *Mfa) ToMfaOutput() MfaOutput {
	return i.ToMfaOutputWithContext(context.Background())
}

func (i *Mfa) ToMfaOutputWithContext(ctx context.Context) MfaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MfaOutput)
}

// MfaArrayInput is an input type that accepts MfaArray and MfaArrayOutput values.
// You can construct a concrete instance of `MfaArrayInput` via:
//
//	MfaArray{ MfaArgs{...} }
type MfaArrayInput interface {
	pulumi.Input

	ToMfaArrayOutput() MfaArrayOutput
	ToMfaArrayOutputWithContext(context.Context) MfaArrayOutput
}

type MfaArray []MfaInput

func (MfaArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Mfa)(nil)).Elem()
}

func (i MfaArray) ToMfaArrayOutput() MfaArrayOutput {
	return i.ToMfaArrayOutputWithContext(context.Background())
}

func (i MfaArray) ToMfaArrayOutputWithContext(ctx context.Context) MfaArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MfaArrayOutput)
}

// MfaMapInput is an input type that accepts MfaMap and MfaMapOutput values.
// You can construct a concrete instance of `MfaMapInput` via:
//
//	MfaMap{ "key": MfaArgs{...} }
type MfaMapInput interface {
	pulumi.Input

	ToMfaMapOutput() MfaMapOutput
	ToMfaMapOutputWithContext(context.Context) MfaMapOutput
}

type MfaMap map[string]MfaInput

func (MfaMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Mfa)(nil)).Elem()
}

func (i MfaMap) ToMfaMapOutput() MfaMapOutput {
	return i.ToMfaMapOutputWithContext(context.Background())
}

func (i MfaMap) ToMfaMapOutputWithContext(ctx context.Context) MfaMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MfaMapOutput)
}

type MfaOutput struct{ *pulumi.OutputState }

func (MfaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Mfa)(nil)).Elem()
}

func (o MfaOutput) ToMfaOutput() MfaOutput {
	return o
}

func (o MfaOutput) ToMfaOutputWithContext(ctx context.Context) MfaOutput {
	return o
}

// Policy Description
func (o MfaOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

func (o MfaOutput) Duo() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.Duo }).(pulumi.StringMapOutput)
}

// Deprecated: Since okta now support multiple external_idps, this will be deprecated. Please use `externalIdps` instead
func (o MfaOutput) ExternalIdp() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.ExternalIdp }).(pulumi.StringMapOutput)
}

func (o MfaOutput) ExternalIdps() pulumi.StringMapArrayOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapArrayOutput { return v.ExternalIdps }).(pulumi.StringMapArrayOutput)
}

func (o MfaOutput) FidoU2f() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.FidoU2f }).(pulumi.StringMapOutput)
}

func (o MfaOutput) FidoWebauthn() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.FidoWebauthn }).(pulumi.StringMapOutput)
}

func (o MfaOutput) GoogleOtp() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.GoogleOtp }).(pulumi.StringMapOutput)
}

// List of Group IDs to Include
func (o MfaOutput) GroupsIncludeds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringArrayOutput { return v.GroupsIncludeds }).(pulumi.StringArrayOutput)
}

func (o MfaOutput) Hotp() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.Hotp }).(pulumi.StringMapOutput)
}

// Is the policy using Okta Identity Engine (OIE) with authenticators instead of factors?
func (o MfaOutput) IsOie() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Mfa) pulumi.BoolPtrOutput { return v.IsOie }).(pulumi.BoolPtrOutput)
}

// Policy Name
func (o MfaOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

func (o MfaOutput) OktaCall() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.OktaCall }).(pulumi.StringMapOutput)
}

func (o MfaOutput) OktaEmail() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.OktaEmail }).(pulumi.StringMapOutput)
}

func (o MfaOutput) OktaOtp() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.OktaOtp }).(pulumi.StringMapOutput)
}

func (o MfaOutput) OktaPassword() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.OktaPassword }).(pulumi.StringMapOutput)
}

func (o MfaOutput) OktaPush() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.OktaPush }).(pulumi.StringMapOutput)
}

func (o MfaOutput) OktaQuestion() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.OktaQuestion }).(pulumi.StringMapOutput)
}

func (o MfaOutput) OktaSms() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.OktaSms }).(pulumi.StringMapOutput)
}

func (o MfaOutput) OktaVerify() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.OktaVerify }).(pulumi.StringMapOutput)
}

func (o MfaOutput) OnpremMfa() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.OnpremMfa }).(pulumi.StringMapOutput)
}

func (o MfaOutput) PhoneNumber() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.PhoneNumber }).(pulumi.StringMapOutput)
}

// Policy Priority, this attribute can be set to a valid priority. To avoid endless diff situation we error if an invalid priority is provided. API defaults it to the last (lowest) if not there.
func (o MfaOutput) Priority() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Mfa) pulumi.IntPtrOutput { return v.Priority }).(pulumi.IntPtrOutput)
}

func (o MfaOutput) RsaToken() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.RsaToken }).(pulumi.StringMapOutput)
}

func (o MfaOutput) SecurityQuestion() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.SecurityQuestion }).(pulumi.StringMapOutput)
}

func (o MfaOutput) SmartCardIdp() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.SmartCardIdp }).(pulumi.StringMapOutput)
}

// Policy Status: `ACTIVE` or `INACTIVE`. Default: `ACTIVE`
func (o MfaOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringPtrOutput { return v.Status }).(pulumi.StringPtrOutput)
}

func (o MfaOutput) SymantecVip() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.SymantecVip }).(pulumi.StringMapOutput)
}

func (o MfaOutput) Webauthn() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.Webauthn }).(pulumi.StringMapOutput)
}

func (o MfaOutput) YubikeyToken() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Mfa) pulumi.StringMapOutput { return v.YubikeyToken }).(pulumi.StringMapOutput)
}

type MfaArrayOutput struct{ *pulumi.OutputState }

func (MfaArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Mfa)(nil)).Elem()
}

func (o MfaArrayOutput) ToMfaArrayOutput() MfaArrayOutput {
	return o
}

func (o MfaArrayOutput) ToMfaArrayOutputWithContext(ctx context.Context) MfaArrayOutput {
	return o
}

func (o MfaArrayOutput) Index(i pulumi.IntInput) MfaOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Mfa {
		return vs[0].([]*Mfa)[vs[1].(int)]
	}).(MfaOutput)
}

type MfaMapOutput struct{ *pulumi.OutputState }

func (MfaMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Mfa)(nil)).Elem()
}

func (o MfaMapOutput) ToMfaMapOutput() MfaMapOutput {
	return o
}

func (o MfaMapOutput) ToMfaMapOutputWithContext(ctx context.Context) MfaMapOutput {
	return o
}

func (o MfaMapOutput) MapIndex(k pulumi.StringInput) MfaOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Mfa {
		return vs[0].(map[string]*Mfa)[vs[1].(string)]
	}).(MfaOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*MfaInput)(nil)).Elem(), &Mfa{})
	pulumi.RegisterInputType(reflect.TypeOf((*MfaArrayInput)(nil)).Elem(), MfaArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*MfaMapInput)(nil)).Elem(), MfaMap{})
	pulumi.RegisterOutputType(MfaOutput{})
	pulumi.RegisterOutputType(MfaArrayOutput{})
	pulumi.RegisterOutputType(MfaMapOutput{})
}
