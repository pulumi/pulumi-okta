// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package okta

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-okta/sdk/v6/go/okta/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Creates and manages a Hook Key. This resource allows you to create and configure an Okta [Hook Key](https://developer.okta.com/docs/reference/api/hook-keys/).
//
// Use Key Management to create and manage JSON Web Keys (JWKS) that support OAuth 2.0 client authentication. The key is composed of a public and private key pair. The private key signs the JSON Web Token (JWT) and the public key validates it on the client side.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-okta/sdk/v6/go/okta"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := okta.NewHookKey(ctx, "example", &okta.HookKeyArgs{
//				Name: pulumi.String("My Hook Key"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Hook Keys can be imported using the `id`.
//
// ```sh
// $ pulumi import okta:index/hookKey:HookKey example &#60;hook_key_id&#62;
// ```
type HookKey struct {
	pulumi.CustomResourceState

	// Timestamp when the key was created.
	Created pulumi.StringOutput `pulumi:"created"`
	// Whether this key is currently in use by other applications.
	IsUsed pulumi.BoolOutput `pulumi:"isUsed"`
	// The alias of the public key.
	KeyId pulumi.StringOutput `pulumi:"keyId"`
	// Timestamp when the key was updated.
	LastUpdated pulumi.StringOutput `pulumi:"lastUpdated"`
	// Display name for the key. Must be between 1 and 255 characters.
	Name pulumi.StringOutput `pulumi:"name"`
}

// NewHookKey registers a new resource with the given unique name, arguments, and options.
func NewHookKey(ctx *pulumi.Context,
	name string, args *HookKeyArgs, opts ...pulumi.ResourceOption) (*HookKey, error) {
	if args == nil {
		args = &HookKeyArgs{}
	}

	opts = internal.PkgResourceDefaultOpts(opts)
	var resource HookKey
	err := ctx.RegisterResource("okta:index/hookKey:HookKey", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetHookKey gets an existing HookKey resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetHookKey(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *HookKeyState, opts ...pulumi.ResourceOption) (*HookKey, error) {
	var resource HookKey
	err := ctx.ReadResource("okta:index/hookKey:HookKey", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering HookKey resources.
type hookKeyState struct {
	// Timestamp when the key was created.
	Created *string `pulumi:"created"`
	// Whether this key is currently in use by other applications.
	IsUsed *bool `pulumi:"isUsed"`
	// The alias of the public key.
	KeyId *string `pulumi:"keyId"`
	// Timestamp when the key was updated.
	LastUpdated *string `pulumi:"lastUpdated"`
	// Display name for the key. Must be between 1 and 255 characters.
	Name *string `pulumi:"name"`
}

type HookKeyState struct {
	// Timestamp when the key was created.
	Created pulumi.StringPtrInput
	// Whether this key is currently in use by other applications.
	IsUsed pulumi.BoolPtrInput
	// The alias of the public key.
	KeyId pulumi.StringPtrInput
	// Timestamp when the key was updated.
	LastUpdated pulumi.StringPtrInput
	// Display name for the key. Must be between 1 and 255 characters.
	Name pulumi.StringPtrInput
}

func (HookKeyState) ElementType() reflect.Type {
	return reflect.TypeOf((*hookKeyState)(nil)).Elem()
}

type hookKeyArgs struct {
	// Display name for the key. Must be between 1 and 255 characters.
	Name *string `pulumi:"name"`
}

// The set of arguments for constructing a HookKey resource.
type HookKeyArgs struct {
	// Display name for the key. Must be between 1 and 255 characters.
	Name pulumi.StringPtrInput
}

func (HookKeyArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*hookKeyArgs)(nil)).Elem()
}

type HookKeyInput interface {
	pulumi.Input

	ToHookKeyOutput() HookKeyOutput
	ToHookKeyOutputWithContext(ctx context.Context) HookKeyOutput
}

func (*HookKey) ElementType() reflect.Type {
	return reflect.TypeOf((**HookKey)(nil)).Elem()
}

func (i *HookKey) ToHookKeyOutput() HookKeyOutput {
	return i.ToHookKeyOutputWithContext(context.Background())
}

func (i *HookKey) ToHookKeyOutputWithContext(ctx context.Context) HookKeyOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HookKeyOutput)
}

// HookKeyArrayInput is an input type that accepts HookKeyArray and HookKeyArrayOutput values.
// You can construct a concrete instance of `HookKeyArrayInput` via:
//
//	HookKeyArray{ HookKeyArgs{...} }
type HookKeyArrayInput interface {
	pulumi.Input

	ToHookKeyArrayOutput() HookKeyArrayOutput
	ToHookKeyArrayOutputWithContext(context.Context) HookKeyArrayOutput
}

type HookKeyArray []HookKeyInput

func (HookKeyArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*HookKey)(nil)).Elem()
}

func (i HookKeyArray) ToHookKeyArrayOutput() HookKeyArrayOutput {
	return i.ToHookKeyArrayOutputWithContext(context.Background())
}

func (i HookKeyArray) ToHookKeyArrayOutputWithContext(ctx context.Context) HookKeyArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HookKeyArrayOutput)
}

// HookKeyMapInput is an input type that accepts HookKeyMap and HookKeyMapOutput values.
// You can construct a concrete instance of `HookKeyMapInput` via:
//
//	HookKeyMap{ "key": HookKeyArgs{...} }
type HookKeyMapInput interface {
	pulumi.Input

	ToHookKeyMapOutput() HookKeyMapOutput
	ToHookKeyMapOutputWithContext(context.Context) HookKeyMapOutput
}

type HookKeyMap map[string]HookKeyInput

func (HookKeyMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*HookKey)(nil)).Elem()
}

func (i HookKeyMap) ToHookKeyMapOutput() HookKeyMapOutput {
	return i.ToHookKeyMapOutputWithContext(context.Background())
}

func (i HookKeyMap) ToHookKeyMapOutputWithContext(ctx context.Context) HookKeyMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HookKeyMapOutput)
}

type HookKeyOutput struct{ *pulumi.OutputState }

func (HookKeyOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HookKey)(nil)).Elem()
}

func (o HookKeyOutput) ToHookKeyOutput() HookKeyOutput {
	return o
}

func (o HookKeyOutput) ToHookKeyOutputWithContext(ctx context.Context) HookKeyOutput {
	return o
}

// Timestamp when the key was created.
func (o HookKeyOutput) Created() pulumi.StringOutput {
	return o.ApplyT(func(v *HookKey) pulumi.StringOutput { return v.Created }).(pulumi.StringOutput)
}

// Whether this key is currently in use by other applications.
func (o HookKeyOutput) IsUsed() pulumi.BoolOutput {
	return o.ApplyT(func(v *HookKey) pulumi.BoolOutput { return v.IsUsed }).(pulumi.BoolOutput)
}

// The alias of the public key.
func (o HookKeyOutput) KeyId() pulumi.StringOutput {
	return o.ApplyT(func(v *HookKey) pulumi.StringOutput { return v.KeyId }).(pulumi.StringOutput)
}

// Timestamp when the key was updated.
func (o HookKeyOutput) LastUpdated() pulumi.StringOutput {
	return o.ApplyT(func(v *HookKey) pulumi.StringOutput { return v.LastUpdated }).(pulumi.StringOutput)
}

// Display name for the key. Must be between 1 and 255 characters.
func (o HookKeyOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *HookKey) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

type HookKeyArrayOutput struct{ *pulumi.OutputState }

func (HookKeyArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*HookKey)(nil)).Elem()
}

func (o HookKeyArrayOutput) ToHookKeyArrayOutput() HookKeyArrayOutput {
	return o
}

func (o HookKeyArrayOutput) ToHookKeyArrayOutputWithContext(ctx context.Context) HookKeyArrayOutput {
	return o
}

func (o HookKeyArrayOutput) Index(i pulumi.IntInput) HookKeyOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *HookKey {
		return vs[0].([]*HookKey)[vs[1].(int)]
	}).(HookKeyOutput)
}

type HookKeyMapOutput struct{ *pulumi.OutputState }

func (HookKeyMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*HookKey)(nil)).Elem()
}

func (o HookKeyMapOutput) ToHookKeyMapOutput() HookKeyMapOutput {
	return o
}

func (o HookKeyMapOutput) ToHookKeyMapOutputWithContext(ctx context.Context) HookKeyMapOutput {
	return o
}

func (o HookKeyMapOutput) MapIndex(k pulumi.StringInput) HookKeyOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *HookKey {
		return vs[0].(map[string]*HookKey)[vs[1].(string)]
	}).(HookKeyOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*HookKeyInput)(nil)).Elem(), &HookKey{})
	pulumi.RegisterInputType(reflect.TypeOf((*HookKeyArrayInput)(nil)).Elem(), HookKeyArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HookKeyMapInput)(nil)).Elem(), HookKeyMap{})
	pulumi.RegisterOutputType(HookKeyOutput{})
	pulumi.RegisterOutputType(HookKeyArrayOutput{})
	pulumi.RegisterOutputType(HookKeyMapOutput{})
}
